"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[6650],{6720:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2/Gazebo-Simulation/lesson-1.3-robot-integration-in-gazebo","title":"Lesson 1.3 \u2013 Robot Integration in Gazebo","description":"Learning Objectives","source":"@site/docs/module-2/01-Gazebo-Simulation/lesson-1.3-robot-integration-in-gazebo.md","sourceDirName":"module-2/01-Gazebo-Simulation","slug":"/module-2/Gazebo-Simulation/lesson-1.3-robot-integration-in-gazebo","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-2/Gazebo-Simulation/lesson-1.3-robot-integration-in-gazebo","draft":false,"unlisted":false,"editUrl":"https://github.com/AmanNazim/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/edit/main/physical-ai-humanoid-robotics-book/docs/module-2/01-Gazebo-Simulation/lesson-1.3-robot-integration-in-gazebo.md","tags":[],"version":"current","frontMatter":{"title":"Lesson 1.3 \u2013 Robot Integration in Gazebo"},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 1.2 \u2013 Environment Creation and World Building","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-2/Gazebo-Simulation/lesson-1.2-environment-creation-and-world-building"},"next":{"title":"Chapter 2 \u2013 Physics & Sensors","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-2/Physics-&-Sensors/"}}');var r=i(4848),t=i(8453);const s={title:"Lesson 1.3 \u2013 Robot Integration in Gazebo"},a="Lesson 1.3 \u2013 Robot Integration in Gazebo",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Robot Integration",id:"introduction-to-robot-integration",level:2},{value:"Why URDF to SDF Conversion?",id:"why-urdf-to-sdf-conversion",level:3},{value:"Understanding URDF to SDF Conversion",id:"understanding-urdf-to-sdf-conversion",level:2},{value:"Key Differences Between URDF and SDF",id:"key-differences-between-urdf-and-sdf",level:3},{value:"Conversion Process",id:"conversion-process",level:3},{value:"Converting URDF to SDF Format",id:"converting-urdf-to-sdf-format",level:2},{value:"Method 1: Using the gz sdf Command",id:"method-1-using-the-gz-sdf-command",level:3},{value:"Method 2: Using xacro to Generate URDF First",id:"method-2-using-xacro-to-generate-urdf-first",level:3},{value:"Example Conversion Process",id:"example-conversion-process",level:3},{value:"Adding Gazebo-Specific Elements to URDF",id:"adding-gazebo-specific-elements-to-urdf",level:2},{value:"Physics Properties",id:"physics-properties",level:3},{value:"Inertial Properties",id:"inertial-properties",level:3},{value:"Sensor Integration",id:"sensor-integration",level:3},{value:"Configuring Joint Constraints and Properties",id:"configuring-joint-constraints-and-properties",level:2},{value:"Joint Types in Gazebo",id:"joint-types-in-gazebo",level:3},{value:"Joint Limitations and Properties",id:"joint-limitations-and-properties",level:3},{value:"Advanced Joint Configuration",id:"advanced-joint-configuration",level:3},{value:"Collision Properties Configuration",id:"collision-properties-configuration",level:2},{value:"Collision Detection Parameters",id:"collision-detection-parameters",level:3},{value:"Self-Collision Avoidance",id:"self-collision-avoidance",level:3},{value:"Spawning Robots in Gazebo",id:"spawning-robots-in-gazebo",level:2},{value:"Method 1: Using the spawn_model Service",id:"method-1-using-the-spawn_model-service",level:3},{value:"Method 2: Launch File Integration",id:"method-2-launch-file-integration",level:3},{value:"Method 3: Direct SDF Integration in World Files",id:"method-3-direct-sdf-integration-in-world-files",level:3},{value:"Testing Robot Integration",id:"testing-robot-integration",level:2},{value:"Basic Functionality Test",id:"basic-functionality-test",level:3},{value:"Joint Movement Test",id:"joint-movement-test",level:3},{value:"Sensor Data Verification",id:"sensor-data-verification",level:3},{value:"Troubleshooting Common Integration Issues",id:"troubleshooting-common-integration-issues",level:2},{value:"Issue: Robot Falls Through Ground",id:"issue-robot-falls-through-ground",level:3},{value:"Issue: Robot Explodes or Behaves Erratically",id:"issue-robot-explodes-or-behaves-erratically",level:3},{value:"Issue: Model Doesn&#39;t Appear",id:"issue-model-doesnt-appear",level:3},{value:"Issue: Joint Limits Not Working",id:"issue-joint-limits-not-working",level:3},{value:"Tools Required for This Lesson",id:"tools-required-for-this-lesson",level:2},{value:"Best Practices for Robot Integration",id:"best-practices-for-robot-integration",level:2},{value:"1. Verify Inertial Properties",id:"1-verify-inertial-properties",level:3},{value:"2. Test Incrementally",id:"2-test-incrementally",level:3},{value:"3. Use Proper Scaling",id:"3-use-proper-scaling",level:3},{value:"4. Configure Physics Appropriately",id:"4-configure-physics-appropriately",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"lesson-13--robot-integration-in-gazebo",children:"Lesson 1.3 \u2013 Robot Integration in Gazebo"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Import and configure humanoid robots in Gazebo simulation from URDF models"}),"\n",(0,r.jsx)(n.li,{children:"Convert URDF to SDF format for Gazebo compatibility"}),"\n",(0,r.jsx)(n.li,{children:"Configure joint constraints and collision properties for humanoid robots"}),"\n",(0,r.jsx)(n.li,{children:"Understand the relationship between URDF and SDF formats"}),"\n",(0,r.jsx)(n.li,{children:"Test and validate robot integration in the Gazebo environment"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction-to-robot-integration",children:"Introduction to Robot Integration"}),"\n",(0,r.jsx)(n.p,{children:"Now that you have Gazebo installed and can create custom environments, it's time to bring your humanoid robots into the simulation. This lesson focuses on integrating the robot models you created in Module 1 (in URDF format) into the Gazebo simulation environment."}),"\n",(0,r.jsx)(n.h3,{id:"why-urdf-to-sdf-conversion",children:"Why URDF to SDF Conversion?"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo uses SDF (Simulation Description Format) as its native format, while ROS 2 typically uses URDF (Unified Robot Description Format). The conversion process ensures that your robot models can be properly interpreted by Gazebo's physics engine and visualization system."}),"\n",(0,r.jsx)(n.h2,{id:"understanding-urdf-to-sdf-conversion",children:"Understanding URDF to SDF Conversion"}),"\n",(0,r.jsx)(n.h3,{id:"key-differences-between-urdf-and-sdf",children:"Key Differences Between URDF and SDF"}),"\n",(0,r.jsx)(n.p,{children:"While both formats describe robot models, they have different focuses:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"URDF"}),": Primarily for kinematic and geometric description"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SDF"}),": Comprehensive format for simulation including physics properties"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"conversion-process",children:"Conversion Process"}),"\n",(0,r.jsx)(n.p,{children:"The conversion from URDF to SDF typically involves:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Geometry conversion"}),": Translating visual and collision geometries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics property addition"}),": Adding mass, inertia, and friction parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simulation-specific elements"}),": Adding Gazebo-specific plugins and properties"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"converting-urdf-to-sdf-format",children:"Converting URDF to SDF Format"}),"\n",(0,r.jsx)(n.h3,{id:"method-1-using-the-gz-sdf-command",children:"Method 1: Using the gz sdf Command"}),"\n",(0,r.jsx)(n.p,{children:"The most straightforward way to convert URDF to SDF is using Gazebo's command-line tools:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Convert a URDF file to SDF\ngz sdf -p /path/to/your/robot.urdf > /path/to/output/robot.sdf\n"})}),"\n",(0,r.jsx)(n.h3,{id:"method-2-using-xacro-to-generate-urdf-first",children:"Method 2: Using xacro to Generate URDF First"}),"\n",(0,r.jsx)(n.p,{children:"If your robot model uses xacro (XML macros), you'll need to generate the URDF first:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Generate URDF from xacro\nros2 run xacro xacro /path/to/your/robot.xacro > /tmp/robot.urdf\n\n# Then convert to SDF\ngz sdf -p /tmp/robot.urdf > /path/to/output/robot.sdf\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-conversion-process",children:"Example Conversion Process"}),"\n",(0,r.jsx)(n.p,{children:"Let's convert a simple humanoid robot model:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create a simple URDF file"})," (robot.urdf):"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.5 0.5 0.2"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.5 0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Torso --\x3e\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.3 0.3 0.5"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.3 0.5"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.02"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joint connecting base to torso --\x3e\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.35"/>\n  </joint>\n\n  \x3c!-- Add Gazebo-specific elements --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/Blue</material>\n  </gazebo>\n\n  <gazebo reference="torso">\n    <material>Gazebo/Red</material>\n  </gazebo>\n</robot>\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Convert to SDF"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gz sdf -p robot.urdf > robot.sdf\n"})}),"\n",(0,r.jsx)(n.h2,{id:"adding-gazebo-specific-elements-to-urdf",children:"Adding Gazebo-Specific Elements to URDF"}),"\n",(0,r.jsx)(n.p,{children:"Before conversion, you can add Gazebo-specific elements to your URDF to ensure proper simulation behavior:"}),"\n",(0,r.jsx)(n.h3,{id:"physics-properties",children:"Physics Properties"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="link_name">\n  <mu1>0.2</mu1>  \x3c!-- Friction coefficient --\x3e\n  <mu2>0.2</mu2>  \x3c!-- Friction coefficient in the second direction --\x3e\n  <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n  <kd>100000.0</kd>  \x3c!-- Contact damping --\x3e\n  <material>Gazebo/Blue</material>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"inertial-properties",children:"Inertial Properties"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="link_name">\n  \x3c!-- Override inertial properties if needed --\x3e\n  <self_collide>false</self_collide>  \x3c!-- Prevent self-collision --\x3e\n  <gravity>true</gravity>  \x3c!-- Enable gravity for this link --\x3e\n  <max_contacts>10</max_contacts>  \x3c!-- Maximum contacts for this link --\x3e\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"sensor-integration",children:"Sensor Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="sensor_link">\n  <sensor name="camera_sensor" type="camera">\n    <pose>0 0 0 0 0 0</pose>\n    <visualize>true</visualize>\n    <update_rate>30.0</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.3962634</horizontal_fov>\n      <image>\n        <width>800</width>\n        <height>600</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>100</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <frame_name>camera_frame</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"configuring-joint-constraints-and-properties",children:"Configuring Joint Constraints and Properties"}),"\n",(0,r.jsx)(n.h3,{id:"joint-types-in-gazebo",children:"Joint Types in Gazebo"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo supports various joint types that correspond to URDF joint types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fixed"}),": No movement between links"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Revolute"}),": Rotational movement around a single axis"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prismatic"}),": Linear movement along a single axis"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Continuous"}),": Rotational movement without limits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Floating"}),": 6-DOF movement"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Planar"}),": Movement on a plane"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"joint-limitations-and-properties",children:"Joint Limitations and Properties"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<joint name="joint_name" type="revolute">\n  <parent link="parent_link"/>\n  <child link="child_link"/>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n  <dynamics damping="0.1" friction="0.0"/>\n</joint>\n\n\x3c!-- Gazebo-specific joint properties --\x3e\n<gazebo reference="joint_name">\n  <provide_feedback>true</provide_feedback>\n  <implicit_spring_damper>true</implicit_spring_damper>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-joint-configuration",children:"Advanced Joint Configuration"}),"\n",(0,r.jsx)(n.p,{children:"For humanoid robots, precise joint configuration is crucial:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="hip_joint">\n  <provide_feedback>true</provide_feedback>\n  <implicit_spring_damper>true</implicit_spring_damper>\n  <axis>\n    <xyz>0 0 1</xyz>\n    <limit>\n      <lower>-1.57</lower>\n      <upper>1.57</upper>\n      <effort>200</effort>\n      <velocity>2</velocity>\n    </limit>\n    <dynamics>\n      <damping>1.0</damping>\n      <friction>0.1</friction>\n    </dynamics>\n  </axis>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"collision-properties-configuration",children:"Collision Properties Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"collision-detection-parameters",children:"Collision Detection Parameters"}),"\n",(0,r.jsx)(n.p,{children:"Proper collision configuration is essential for realistic physics simulation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="link_name">\n  <collision>\n    <max_contacts>10</max_contacts>\n    <surface>\n      <contact>\n        <ode>\n          <kp>1e+6</kp>  \x3c!-- Contact stiffness --\x3e\n          <kd>1e+3</kd>  \x3c!-- Contact damping --\x3e\n          <max_vel>100.0</max_vel>\n          <min_depth>0.001</min_depth>\n        </ode>\n      </contact>\n      <friction>\n        <ode>\n          <mu>0.5</mu>\n          <mu2>0.5</mu2>\n          <fdir1>0 0 1</fdir1>\n          <slip1>0.0</slip1>\n          <slip2>0.0</slip2>\n        </ode>\n      </friction>\n    </surface>\n  </collision>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"self-collision-avoidance",children:"Self-Collision Avoidance"}),"\n",(0,r.jsx)(n.p,{children:"For complex humanoid robots with many links, you may want to disable self-collision between certain pairs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<gazebo>\n  <static>false</static>\n  <self_collide>false</self_collide>\n  <enable_wind>false</enable_wind>\n  <kinematic>false</kinematic>\n  <gravity>true</gravity>\n</gazebo>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"spawning-robots-in-gazebo",children:"Spawning Robots in Gazebo"}),"\n",(0,r.jsx)(n.h3,{id:"method-1-using-the-spawn_model-service",children:"Method 1: Using the spawn_model Service"}),"\n",(0,r.jsx)(n.p,{children:"Once you have your SDF file, you can spawn the robot in Gazebo:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Spawn a model from an SDF file\nros2 run gazebo_ros spawn_entity.py -file /path/to/robot.sdf -entity my_robot -x 0 -y 0 -z 1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"method-2-launch-file-integration",children:"Method 2: Launch File Integration"}),"\n",(0,r.jsx)(n.p,{children:"Create a launch file that starts Gazebo and spawns your robot:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch Gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': PathJoinSubstitution([\n                FindPackageShare('my_robot_description'),\n                'worlds',\n                'my_world.world'\n            ])\n        }.items()\n    )\n\n    # Spawn robot\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-entity', 'my_robot',\n            '-file', PathJoinSubstitution([\n                FindPackageShare('my_robot_description'),\n                'models',\n                'robot.sdf'\n            ]),\n            '-x', '0',\n            '-y', '0',\n            '-z', '0.5'\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gazebo,\n        spawn_entity\n    ])\n"})}),"\n",(0,r.jsx)(n.h3,{id:"method-3-direct-sdf-integration-in-world-files",children:"Method 3: Direct SDF Integration in World Files"}),"\n",(0,r.jsx)(n.p,{children:"You can also include your robot directly in world files:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="robot_world">\n    \x3c!-- Physics configuration --\x3e\n    <physics type="ode">\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Include your robot model directly --\x3e\n    <include>\n      <uri>model://my_robot</uri>\n      <pose>0 0 0.5 0 0 0</pose>\n    </include>\n\n    \x3c!-- Other world elements --\x3e\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing-robot-integration",children:"Testing Robot Integration"}),"\n",(0,r.jsx)(n.h3,{id:"basic-functionality-test",children:"Basic Functionality Test"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Launch Gazebo with your environment"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Spawn your robot model"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Verify the robot appears correctly in the simulation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Check that physics properties are working (gravity, collisions)"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"joint-movement-test",children:"Joint Movement Test"}),"\n",(0,r.jsx)(n.p,{children:"If your robot has movable joints, test them:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# List available topics\nros2 topic list | grep joint\n\n# Check joint states\nros2 topic echo /joint_states\n\n# If you have joint controllers, publish commands\nros2 topic pub /joint_trajectory_controller/joint_trajectory trajectory_msgs/msg/JointTrajectory "..."\n'})}),"\n",(0,r.jsx)(n.h3,{id:"sensor-data-verification",children:"Sensor Data Verification"}),"\n",(0,r.jsx)(n.p,{children:"If your robot has sensors, verify they're publishing data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Check for sensor topics\nros2 topic list | grep -E "(camera|imu|lidar|scan)"\n\n# View sensor data\nros2 topic echo /my_robot/camera/image_raw\nros2 topic echo /my_robot/imu/data\n'})}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting-common-integration-issues",children:"Troubleshooting Common Integration Issues"}),"\n",(0,r.jsx)(n.h3,{id:"issue-robot-falls-through-ground",children:"Issue: Robot Falls Through Ground"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Missing collision geometries or incorrect inertial properties"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Verify all links have proper collision elements and mass properties"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"issue-robot-explodes-or-behaves-erratically",children:"Issue: Robot Explodes or Behaves Erratically"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Incorrect inertial properties or joint limits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Check mass, inertia, and joint parameters; ensure values are physically realistic"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"issue-model-doesnt-appear",children:"Issue: Model Doesn't Appear"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Incorrect file path or malformed SDF"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Verify file path and check Gazebo console for error messages"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"issue-joint-limits-not-working",children:"Issue: Joint Limits Not Working"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Joint limits defined in URDF but not properly transferred to SDF"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Add Gazebo-specific joint limit configuration in URDF"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tools-required-for-this-lesson",children:"Tools Required for This Lesson"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"URDF/Xacro"}),": Robot description format from Module 1"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SDF"}),": Simulation Description Format for Gazebo"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo"}),": Physics simulation environment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2 (Humble Hawksbill)"}),": Robot operating system for communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Text Editor"}),": For editing URDF and SDF files"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Command Line Tools"}),": For conversion and spawning operations"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-for-robot-integration",children:"Best Practices for Robot Integration"}),"\n",(0,r.jsx)(n.h3,{id:"1-verify-inertial-properties",children:"1. Verify Inertial Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensure all links have realistic mass and inertia values"}),"\n",(0,r.jsxs)(n.li,{children:["Use the ",(0,r.jsx)(n.code,{children:"inertial_calculator.py"})," tool if needed to calculate proper inertial properties"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-test-incrementally",children:"2. Test Incrementally"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Start with a simple model and gradually add complexity"}),"\n",(0,r.jsx)(n.li,{children:"Test each joint and sensor individually before full integration"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-use-proper-scaling",children:"3. Use Proper Scaling"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensure all dimensions are in meters for consistency"}),"\n",(0,r.jsx)(n.li,{children:"Verify that link sizes are appropriate for humanoid scale"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-configure-physics-appropriately",children:"4. Configure Physics Appropriately"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Set realistic friction and damping values"}),"\n",(0,r.jsx)(n.li,{children:"Configure contact properties for stable simulation"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"In this lesson, you've learned to integrate humanoid robots into the Gazebo simulation environment. You've mastered the conversion from URDF to SDF format, configured joint constraints and collision properties, and learned how to spawn and test robots in simulation."}),"\n",(0,r.jsx)(n.p,{children:"The integration process you've completed creates a bridge between the robot description you created in Module 1 and the simulation environment established in this module. This integration is crucial for testing your robots in a safe, repeatable environment before any potential physical application."}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"With your Gazebo simulation environment established and your robots integrated, you're now ready to advance to Module 2 Chapter 2, where you'll implement sensor simulation systems (LiDAR, Depth Camera, IMU) in the Gazebo environment you've created. The physics parameters and understanding you've gained will be essential as you expand your simulation to include sophisticated sensor modeling."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var o=i(6540);const r={},t=o.createContext(r);function s(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);