"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[9973],{8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},9940:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"module-1/nodes-topics-services-robot-communication/service-based-communication","title":"Service-based Communication","description":"Learning Objectives","source":"@site/docs/module-1/2-nodes-topics-services-robot-communication/service-based-communication.md","sourceDirName":"module-1/2-nodes-topics-services-robot-communication","slug":"/module-1/nodes-topics-services-robot-communication/service-based-communication","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-1/nodes-topics-services-robot-communication/service-based-communication","draft":false,"unlisted":false,"editUrl":"https://github.com/AmanNazim/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/edit/main/physical-ai-humanoid-robotics-book/docs/module-1/2-nodes-topics-services-robot-communication/service-based-communication.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Nodes with Multiple Communication Patterns","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-1/nodes-topics-services-robot-communication/nodes-multiple-communication-patterns"},"next":{"title":"Parameter Server Configuration","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-1/nodes-topics-services-robot-communication/parameter-server-configuration"}}');var i=s(4848),o=s(8453);const r={sidebar_position:3},a="Service-based Communication",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Concept Overview and Scope",id:"concept-overview-and-scope",level:2},{value:"Required Tools and Technologies",id:"required-tools-and-technologies",level:2},{value:"Understanding Service Communication",id:"understanding-service-communication",level:2},{value:"When to Use Services vs Topics",id:"when-to-use-services-vs-topics",level:2},{value:"Creating Custom Service Definitions",id:"creating-custom-service-definitions",level:2},{value:"Implementing a Service Server",id:"implementing-a-service-server",level:2},{value:"Implementing a Service Client",id:"implementing-a-service-client",level:2},{value:"Timeout Handling and Error Responses",id:"timeout-handling-and-error-responses",level:2},{value:"Testing the Service Communication",id:"testing-the-service-communication",level:2},{value:"Service Interface Design Best Practices",id:"service-interface-design-best-practices",level:2},{value:"Comparison: Services vs Topics",id:"comparison-services-vs-topics",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"service-based-communication",children:"Service-based Communication"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement service-server and service-client communication patterns"}),"\n",(0,i.jsx)(n.li,{children:"Understand when to use services vs topics for different communication needs"}),"\n",(0,i.jsx)(n.li,{children:"Handle timeout mechanisms and error responses in service communication"}),"\n",(0,i.jsx)(n.li,{children:"Design proper service interfaces for robot state queries and configuration"}),"\n",(0,i.jsx)(n.li,{children:"Implement reliable service communication with proper error handling"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"concept-overview-and-scope",children:"Concept Overview and Scope"}),"\n",(0,i.jsx)(n.p,{children:"In this lesson, you will learn to implement service-server and service-client communication patterns for synchronous operations in ROS2. Services provide request/response communication that is essential for operations requiring guaranteed completion, state queries, and configuration changes. You will understand when to use services versus topics, implement reliable service communication, and handle synchronous operations within the ROS2 framework."}),"\n",(0,i.jsx)(n.h2,{id:"required-tools-and-technologies",children:"Required Tools and Technologies"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ROS2 Humble Hawksbill"}),"\n",(0,i.jsx)(n.li,{children:"rclpy (Python client library)"}),"\n",(0,i.jsx)(n.li,{children:"Service definition files (.srv)"}),"\n",(0,i.jsx)(n.li,{children:"colcon build system"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"understanding-service-communication",children:"Understanding Service Communication"}),"\n",(0,i.jsx)(n.p,{children:"Service communication in ROS2 follows a request/response pattern where a client sends a request to a server and waits for a response. This synchronous communication is fundamentally different from the asynchronous topic-based communication you learned in previous lessons. Services are ideal for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'State queries (e.g., "What is the current robot position?")'}),"\n",(0,i.jsx)(n.li,{children:'Configuration changes (e.g., "Set the robot to safe mode")'}),"\n",(0,i.jsx)(n.li,{children:'Operations requiring guaranteed completion (e.g., "Execute calibration sequence")'}),"\n",(0,i.jsx)(n.li,{children:'Synchronous data processing (e.g., "Transform these coordinates")'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The key characteristics of service communication are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Synchronous: The client waits for the response"}),"\n",(0,i.jsx)(n.li,{children:"Request/response: One request generates one response"}),"\n",(0,i.jsx)(n.li,{children:"Point-to-point: Direct communication between client and server"}),"\n",(0,i.jsx)(n.li,{children:"Blocking: The client is blocked until the response is received"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-services-vs-topics",children:"When to Use Services vs Topics"}),"\n",(0,i.jsx)(n.p,{children:"Understanding when to use services versus topics is crucial for effective ROS2 design:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use Services When:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You need guaranteed completion of an operation"}),"\n",(0,i.jsx)(n.li,{children:"The operation is synchronous by nature"}),"\n",(0,i.jsx)(n.li,{children:"You need to query current state"}),"\n",(0,i.jsx)(n.li,{children:"You're performing configuration changes"}),"\n",(0,i.jsx)(n.li,{children:"You need to return results from computation"}),"\n",(0,i.jsx)(n.li,{children:"The operation is not frequent (services are not for streaming data)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use Topics When:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You need asynchronous communication"}),"\n",(0,i.jsx)(n.li,{children:"You're streaming data continuously"}),"\n",(0,i.jsx)(n.li,{children:"Multiple subscribers need the same information"}),"\n",(0,i.jsx)(n.li,{children:"You're implementing publish/subscribe patterns"}),"\n",(0,i.jsx)(n.li,{children:"Real-time performance is critical (topics have lower latency)"}),"\n",(0,i.jsx)(n.li,{children:"You're broadcasting information to multiple nodes"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-custom-service-definitions",children:"Creating Custom Service Definitions"}),"\n",(0,i.jsx)(n.p,{children:"Let's create a custom service definition for robot state queries. First, create the service definition file in your package:"}),"\n",(0,i.jsx)(n.p,{children:"Create the services directory in your package:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"mkdir -p advanced_communication_tutorials/advanced_communication_tutorials/srv\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Create a service definition file for robot state queries (",(0,i.jsx)(n.code,{children:"advanced_communication_tutorials/advanced_communication_tutorials/srv/RobotStateQuery.srv"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'# Request: Query type and parameters\nstring query_type  # Type of query: "position", "status", "configuration", etc.\nstring target_frame  # Optional target frame for transforms\n---\n# Response: Query result and success status\nbool success  # Whether the query was successful\nstring message  # Additional information or error message\nfloat64[] values  # Numeric values (positions, angles, etc.)\nstring[] names  # Names corresponding to the values\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Create another service for robot commands (",(0,i.jsx)(n.code,{children:"advanced_communication_tutorials/advanced_communication_tutorials/srv/RobotCommand.srv"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'# Request: Command type and parameters\nstring command_type  # Type of command: "move", "stop", "calibrate", etc.\nfloat64[] parameters  # Command parameters (positions, velocities, etc.)\nstring target_frame  # Optional target frame\n---\n# Response: Command execution result\nbool success  # Whether the command was accepted/started\nstring message  # Additional information or error message\nfloat64 execution_time  # Time taken to execute the command\n'})}),"\n",(0,i.jsx)(n.p,{children:"Update the package.xml to include the service definitions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\n<package format="3">\n  <name>advanced_communication_tutorials</name>\n  <version>0.0.0</version>\n  <description>Advanced ROS2 Communication Tutorials</description>\n  <maintainer email="student@todo.todo">student</maintainer>\n  <license>Apache-2.0</license>\n\n  <depend>rclpy</depend>\n  <depend>std_msgs</depend>\n  <depend>sensor_msgs</depend>\n  <depend>geometry_msgs</depend>\n  <build_depend>rosidl_default_generators</build_depend>\n  <exec_depend>rosidl_default_runtime</exec_depend>\n  <member_of_group>rosidl_interface_packages</member_of_group>\n\n  <test_depend>ament_copyright</test_depend>\n  <test_depend>ament_flake8</test_depend>\n  <test_depend>ament_pep257</test_depend>\n  <test_depend>python3-pytest</test_depend>\n\n  <export>\n    <build_type>ament_python</build_type>\n  </export>\n</package>\n'})}),"\n",(0,i.jsx)(n.p,{children:"Update the setup.py to include service definitions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\nfrom glob import glob\nimport os\n\npackage_name = 'advanced_communication_tutorials'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py')),\n        (os.path.join('share', package_name, 'config'), glob('config/*.yaml'))\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='student',\n    maintainer_email='student@todo.todo',\n    description='Advanced ROS2 Communication Tutorials',\n    license='Apache-2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'multi_communication_node = advanced_communication_tutorials.multi_communication_node:main',\n            'sensor_publisher = advanced_communication_tutorials.sensor_publisher:main',\n            'robot_state_server = advanced_communication_tutorials.robot_state_server:main',\n            'robot_command_client = advanced_communication_tutorials.robot_command_client:main',\n        ],\n    },\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"implementing-a-service-server",children:"Implementing a Service Server"}),"\n",(0,i.jsxs)(n.p,{children:["Now let's implement a service server that can handle robot state queries. Create the service server file (",(0,i.jsx)(n.code,{children:"advanced_communication_tutorials/advanced_communication_tutorials/robot_state_server.py"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\n"""\nService server for robot state queries.\nImplements RobotStateQuery service to provide current robot state information.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom advanced_communication_tutorials.srv import RobotStateQuery, RobotCommand\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import String\nimport math\n\n\nclass RobotStateServer(Node):\n    """\n    A ROS2 service server that provides robot state information.\n    """\n\n    def __init__(self):\n        super().__init__(\'robot_state_server\')\n\n        # Create service servers\n        self.state_query_service = self.create_service(\n            RobotStateQuery,\n            \'get_robot_state\',\n            self.handle_state_query\n        )\n\n        self.command_service = self.create_service(\n            RobotCommand,\n            \'execute_robot_command\',\n            self.handle_robot_command\n        )\n\n        # Store some simulated robot state\n        self.joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0]  # Simulated joint positions\n        self.robot_status = "IDLE"  # Robot operational status\n        self.is_calibrated = True  # Calibration status\n\n        # Subscribe to actual joint states (if available) to update our simulation\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            \'joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        self.get_logger().info(\'Robot State Server initialized and ready\')\n\n    def joint_state_callback(self, msg):\n        """\n        Update internal state based on received joint states.\n        """\n        if len(msg.position) > 0:\n            self.joint_positions = list(msg.position)[:5]  # Take first 5 joints\n            self.get_logger().debug(f\'Updated joint positions: {self.joint_positions}\')\n\n    def handle_state_query(self, request, response):\n        """\n        Handle robot state query requests.\n        """\n        self.get_logger().info(f\'Received state query: {request.query_type}\')\n\n        if request.query_type == \'position\':\n            response.success = True\n            response.message = "Position query successful"\n            response.values = self.joint_positions\n            response.names = [f\'joint_{i}\' for i in range(len(self.joint_positions))]\n\n        elif request.query_type == \'status\':\n            response.success = True\n            response.message = f"Robot status: {self.robot_status}"\n            response.values = [1.0 if self.is_calibrated else 0.0]  # Calibration status\n            response.names = [\'is_calibrated\']\n\n        elif request.query_type == \'configuration\':\n            response.success = True\n            response.message = "Configuration query successful"\n            response.values = [len(self.joint_positions), 5.0, 10.0]  # [joint_count, max_speed, max_torque]\n            response.names = [\'joint_count\', \'max_speed\', \'max_torque\']\n\n        else:\n            response.success = False\n            response.message = f"Unknown query type: {request.query_type}"\n            response.values = []\n            response.names = []\n\n        self.get_logger().info(f\'Responding to query: success={response.success}, message={response.message}\')\n        return response\n\n    def handle_robot_command(self, request, response):\n        """\n        Handle robot command requests.\n        """\n        self.get_logger().info(f\'Received command: {request.command_type}\')\n\n        # Simulate command execution\n        execution_time = 0.0\n\n        if request.command_type == \'move\':\n            if len(request.parameters) > 0:\n                # Simulate moving to new positions\n                self.joint_positions = list(request.parameters)[:len(self.joint_positions)]\n                self.robot_status = "MOVING"\n                execution_time = 1.0  # Simulated execution time\n                response.success = True\n                response.message = f"Move command executed, new positions: {self.joint_positions}"\n            else:\n                response.success = False\n                response.message = "Move command requires parameters"\n\n        elif request.command_type == \'stop\':\n            self.robot_status = "STOPPED"\n            execution_time = 0.1  # Quick stop\n            response.success = True\n            response.message = "Robot stopped"\n\n        elif request.command_type == \'calibrate\':\n            self.is_calibrated = True\n            self.robot_status = "CALIBRATED"\n            execution_time = 5.0  # Calibration takes longer\n            response.success = True\n            response.message = "Calibration completed"\n\n        else:\n            response.success = False\n            response.message = f"Unknown command type: {request.command_type}"\n\n        response.execution_time = execution_time\n        self.get_logger().info(f\'Responding to command: success={response.success}, message={response.message}\')\n        return response\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    server = RobotStateServer()\n\n    try:\n        rclpy.spin(server)\n    except KeyboardInterrupt:\n        server.get_logger().info(\'Service server interrupted by user\')\n    finally:\n        server.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implementing-a-service-client",children:"Implementing a Service Client"}),"\n",(0,i.jsxs)(n.p,{children:["Now let's implement a service client that can interact with our service server. Create the service client file (",(0,i.jsx)(n.code,{children:"advanced_communication_tutorials/advanced_communication_tutorials/robot_command_client.py"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\n\"\"\"\nService client for robot commands.\nImplements client-side interaction with robot state services.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom advanced_communication_tutorials.srv import RobotStateQuery, RobotCommand\nfrom std_msgs.msg import String\nimport time\n\n\nclass RobotCommandClient(Node):\n    \"\"\"\n    A ROS2 service client that sends commands to the robot state server.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('robot_command_client')\n\n        # Create clients for the services\n        self.state_client = self.create_client(RobotStateQuery, 'get_robot_state')\n        self.command_client = self.create_client(RobotCommand, 'execute_robot_command')\n\n        # Wait for services to be available\n        while not self.state_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('State service not available, waiting again...')\n\n        while not self.command_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Command service not available, waiting again...')\n\n        self.get_logger().info('Service clients initialized and connected')\n\n    def query_robot_state(self, query_type, target_frame=\"\"):\n        \"\"\"\n        Send a state query to the robot and return the response.\n        \"\"\"\n        request = RobotStateQuery.Request()\n        request.query_type = query_type\n        request.target_frame = target_frame\n\n        self.get_logger().info(f'Sending state query: {query_type}')\n\n        # Make the service call with timeout\n        future = self.state_client.call_async(request)\n\n        # Wait for response with timeout\n        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)\n\n        if future.result() is not None:\n            response = future.result()\n            self.get_logger().info(f'State query response: success={response.success}')\n            self.get_logger().info(f'Message: {response.message}')\n            self.get_logger().info(f'Values: {response.values}')\n            self.get_logger().info(f'Names: {response.names}')\n            return response\n        else:\n            self.get_logger().error('Exception while calling service: %r' % future.exception())\n            return None\n\n    def send_robot_command(self, command_type, parameters=None, target_frame=\"\"):\n        \"\"\"\n        Send a command to the robot and return the response.\n        \"\"\"\n        if parameters is None:\n            parameters = []\n\n        request = RobotCommand.Request()\n        request.command_type = command_type\n        request.parameters = parameters\n        request.target_frame = target_frame\n\n        self.get_logger().info(f'Sending command: {command_type} with parameters: {parameters}')\n\n        # Make the service call with timeout\n        future = self.command_client.call_async(request)\n\n        # Wait for response with timeout\n        rclpy.spin_until_future_complete(self, future, timeout_sec=10.0)\n\n        if future.result() is not None:\n            response = future.result()\n            self.get_logger().info(f'Command response: success={response.success}')\n            self.get_logger().info(f'Message: {response.message}')\n            self.get_logger().info(f'Execution time: {response.execution_time}s')\n            return response\n        else:\n            self.get_logger().error('Exception while calling service: %r' % future.exception())\n            return None\n\n    def run_demo_sequence(self):\n        \"\"\"\n        Run a demonstration sequence of service calls.\n        \"\"\"\n        self.get_logger().info('Starting service communication demo...')\n\n        # Query initial robot position\n        self.get_logger().info('\\n--- Querying Initial Robot Position ---')\n        self.query_robot_state('position')\n\n        # Query robot status\n        self.get_logger().info('\\n--- Querying Robot Status ---')\n        self.query_robot_state('status')\n\n        # Query robot configuration\n        self.get_logger().info('\\n--- Querying Robot Configuration ---')\n        self.query_robot_state('configuration')\n\n        # Send a move command\n        self.get_logger().info('\\n--- Sending Move Command ---')\n        move_params = [1.0, 0.5, -0.5, 0.0, 0.3]  # Example joint positions\n        self.send_robot_command('move', move_params)\n\n        # Query position after move\n        self.get_logger().info('\\n--- Querying Position After Move ---')\n        self.query_robot_state('position')\n\n        # Send a stop command\n        self.get_logger().info('\\n--- Sending Stop Command ---')\n        self.send_robot_command('stop')\n\n        # Send a calibration command\n        self.get_logger().info('\\n--- Sending Calibration Command ---')\n        self.send_robot_command('calibrate')\n\n        # Query status after calibration\n        self.get_logger().info('\\n--- Querying Status After Calibration ---')\n        self.query_robot_state('status')\n\n        self.get_logger().info('\\n--- Demo Sequence Complete ---')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    client = RobotCommandClient()\n\n    try:\n        # Run the demo sequence\n        client.run_demo_sequence()\n    except KeyboardInterrupt:\n        client.get_logger().info('Client interrupted by user')\n    finally:\n        client.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"timeout-handling-and-error-responses",children:"Timeout Handling and Error Responses"}),"\n",(0,i.jsxs)(n.p,{children:["Service communication must include proper timeout handling to prevent clients from hanging indefinitely. In our implementation, we use ",(0,i.jsx)(n.code,{children:"rclpy.spin_until_future_complete()"})," with a timeout parameter to ensure that service calls don't block forever."]}),"\n",(0,i.jsx)(n.p,{children:"Error handling in services involves:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Checking if the service is available before making calls"}),"\n",(0,i.jsx)(n.li,{children:"Setting appropriate timeout values based on expected service response time"}),"\n",(0,i.jsx)(n.li,{children:"Handling exceptions that may occur during service calls"}),"\n",(0,i.jsx)(n.li,{children:"Providing meaningful error messages in service responses"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"testing-the-service-communication",children:"Testing the Service Communication"}),"\n",(0,i.jsx)(n.p,{children:"To test the service communication, first build the package with the new service definitions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select advanced_communication_tutorials\nsource install/setup.bash\n"})}),"\n",(0,i.jsx)(n.p,{children:"Run the service server in one terminal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run advanced_communication_tutorials robot_state_server\n"})}),"\n",(0,i.jsx)(n.p,{children:"In another terminal, run the service client:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run advanced_communication_tutorials robot_command_client\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can also test services manually using the command line:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Query robot state\nros2 service call /get_robot_state advanced_communication_tutorials/srv/RobotStateQuery \"{'query_type': 'position'}\"\n\n# Send a move command\nros2 service call /execute_robot_command advanced_communication_tutorials/srv/RobotCommand \"{'command_type': 'move', 'parameters': [1.0, 0.5, -0.5]}\"\n"})}),"\n",(0,i.jsx)(n.h2,{id:"service-interface-design-best-practices",children:"Service Interface Design Best Practices"}),"\n",(0,i.jsx)(n.p,{children:"When designing service interfaces for robot systems, consider these best practices:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Clear Request/Response Structure"}),": Define clear input parameters and output responses that match the operation's purpose."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Always include success/failure indicators and descriptive error messages in responses."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Appropriate Timeout Values"}),": Set timeout values based on the expected execution time of the service."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"State Consistency"}),": Ensure services maintain consistent robot state and don't leave the system in an inconsistent state."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Validation"}),": Validate input parameters before executing service operations."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": Clearly document what each service does, its parameters, and expected behavior."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"comparison-services-vs-topics",children:"Comparison: Services vs Topics"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Services"}),(0,i.jsx)(n.th,{children:"Topics"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Communication Type"}),(0,i.jsx)(n.td,{children:"Synchronous (request/response)"}),(0,i.jsx)(n.td,{children:"Asynchronous (publish/subscribe)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Blocking"}),(0,i.jsx)(n.td,{children:"Client blocks until response"}),(0,i.jsx)(n.td,{children:"Non-blocking"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Use Case"}),(0,i.jsx)(n.td,{children:"State queries, commands, configuration"}),(0,i.jsx)(n.td,{children:"Data streaming, broadcasting"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Latency"}),(0,i.jsx)(n.td,{children:"Higher (due to round-trip)"}),(0,i.jsx)(n.td,{children:"Lower"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Reliability"}),(0,i.jsx)(n.td,{children:"Guaranteed response"}),(0,i.jsx)(n.td,{children:"Best-effort delivery"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Frequency"}),(0,i.jsx)(n.td,{children:"Not suitable for high-frequency"}),(0,i.jsx)(n.td,{children:"Ideal for high-frequency"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"In this lesson, you learned how to implement service-based communication in ROS2. You created custom service definitions, implemented both service servers and clients, and learned about proper timeout handling and error responses. You also understood when to use services versus topics based on the communication requirements. Service communication is essential for synchronous operations in robotic systems, particularly for state queries, commands, and configuration changes that require guaranteed completion."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);