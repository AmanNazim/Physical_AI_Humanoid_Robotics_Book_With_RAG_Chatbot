"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[9703],{2927:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-3/Visual-SLAM-&-Navigation/lesson-2.1-nav2-path-planning-for-humanoid-robots","title":"Lesson 2.1 - Nav2 Path Planning for Humanoid Robots","description":"Learning Objectives","source":"@site/docs/module-3/02-Visual-SLAM-&-Navigation/lesson-2.1-nav2-path-planning-for-humanoid-robots.md","sourceDirName":"module-3/02-Visual-SLAM-&-Navigation","slug":"/module-3/Visual-SLAM-&-Navigation/lesson-2.1-nav2-path-planning-for-humanoid-robots","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-3/Visual-SLAM-&-Navigation/lesson-2.1-nav2-path-planning-for-humanoid-robots","draft":false,"unlisted":false,"editUrl":"https://github.com/AmanNazim/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/edit/main/physical-ai-humanoid-robotics-book/docs/module-3/02-Visual-SLAM-&-Navigation/lesson-2.1-nav2-path-planning-for-humanoid-robots.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Lesson 2.1 - Nav2 Path Planning for Humanoid Robots","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Visual SLAM & Navigation","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-3/Visual-SLAM-&-Navigation/"},"next":{"title":"Lesson 2.2 - Visual SLAM with Isaac ROS","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-3/Visual-SLAM-&-Navigation/lesson-2.2-visual-slam-with-isaac-ros"}}');var i=a(4848),t=a(8453);const s={title:"Lesson 2.1 - Nav2 Path Planning for Humanoid Robots",sidebar_position:2},r="Lesson 2.1: Nav2 Path Planning for Humanoid Robots",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Nav2 for Humanoid Navigation",id:"introduction-to-nav2-for-humanoid-navigation",level:2},{value:"Why Nav2 for Humanoid Robots?",id:"why-nav2-for-humanoid-robots",level:3},{value:"Key Components of Nav2 for Humanoid Navigation",id:"key-components-of-nav2-for-humanoid-navigation",level:3},{value:"Setting Up Nav2 Framework with ROS2 Humble",id:"setting-up-nav2-framework-with-ros2-humble",level:2},{value:"Installing Nav2 Packages",id:"installing-nav2-packages",level:3},{value:"Verifying Nav2 Installation",id:"verifying-nav2-installation",level:3},{value:"Configuring Nav2 for Humanoid Robot Navigation Requirements",id:"configuring-nav2-for-humanoid-robot-navigation-requirements",level:2},{value:"1. Costmap Configuration for Humanoid Form Factor",id:"1-costmap-configuration-for-humanoid-form-factor",level:3},{value:"2. Humanoid-Specific Navigation Parameters",id:"2-humanoid-specific-navigation-parameters",level:3},{value:"Velocity Limits",id:"velocity-limits",level:4},{value:"Costmap Adjustments",id:"costmap-adjustments",level:4},{value:"Controller Configuration",id:"controller-configuration",level:4},{value:"3. Launch Configuration for Humanoid Navigation",id:"3-launch-configuration-for-humanoid-navigation",level:3},{value:"Adapting Path Planning for Bipedal Locomotion Constraints",id:"adapting-path-planning-for-bipedal-locomotion-constraints",level:2},{value:"Understanding Bipedal Locomotion Constraints",id:"understanding-bipedal-locomotion-constraints",level:3},{value:"Modifying Planner Parameters",id:"modifying-planner-parameters",level:3},{value:"Implementing Custom Path Smoothing for Humanoid Movement",id:"implementing-custom-path-smoothing-for-humanoid-movement",level:3},{value:"Collision Avoidance for Humanoid Form Factor",id:"collision-avoidance-for-humanoid-form-factor",level:3},{value:"Height-Aware Collision Detection",id:"height-aware-collision-detection",level:4},{value:"Dynamic Footprint for Bipedal Walking",id:"dynamic-footprint-for-bipedal-walking",level:4},{value:"Testing Navigation in Isaac Sim Environment",id:"testing-navigation-in-isaac-sim-environment",level:2},{value:"Setting Up Isaac Sim for Humanoid Navigation",id:"setting-up-isaac-sim-for-humanoid-navigation",level:3},{value:"Creating a Navigation Test Script",id:"creating-a-navigation-test-script",level:3},{value:"Validating Path Planning for Bipedal Locomotion",id:"validating-path-planning-for-bipedal-locomotion",level:3},{value:"Integration with Isaac ROS Packages",id:"integration-with-isaac-ros-packages",level:2},{value:"Isaac ROS Perception Integration",id:"isaac-ros-perception-integration",level:3},{value:"Isaac ROS Navigation Integration",id:"isaac-ros-navigation-integration",level:3},{value:"Summary",id:"summary",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"lesson-21-nav2-path-planning-for-humanoid-robots",children:"Lesson 2.1: Nav2 Path Planning for Humanoid Robots"})}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(e.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Configure Nav2 path planning specifically adapted for humanoid robots"}),"\n",(0,i.jsx)(e.li,{children:"Set up Nav2 framework with ROS2 Humble for humanoid navigation requirements"}),"\n",(0,i.jsx)(e.li,{children:"Adapt path planning for bipedal locomotion constraints and humanoid robot kinematics"}),"\n",(0,i.jsx)(e.li,{children:"Configure collision avoidance for humanoid form factor"}),"\n",(0,i.jsx)(e.li,{children:"Test navigation in Isaac Sim environment with humanoid-specific constraints"}),"\n",(0,i.jsx)(e.li,{children:"Validate path planning for bipedal locomotion"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-nav2-for-humanoid-navigation",children:"Introduction to Nav2 for Humanoid Navigation"}),"\n",(0,i.jsx)(e.p,{children:"Navigation2 (Nav2) is a comprehensive navigation stack designed for mobile robots operating in dynamic environments. While traditionally used for wheeled robots, Nav2 can be adapted for humanoid robots with specific configurations that account for the unique challenges of bipedal locomotion. In this lesson, we'll explore how to configure Nav2 specifically for humanoid robots, considering factors such as balance, foot placement, and anthropomorphic movement patterns."}),"\n",(0,i.jsx)(e.h3,{id:"why-nav2-for-humanoid-robots",children:"Why Nav2 for Humanoid Robots?"}),"\n",(0,i.jsx)(e.p,{children:"Unlike traditional wheeled robots, humanoid robots face unique navigation challenges:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Bipedal locomotion constraints"}),": Humanoid robots must maintain balance while navigating, requiring careful consideration of step placement and center of mass"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Anthropomorphic form factor"}),": The tall, narrow profile of humanoid robots affects collision detection and space requirements"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic stability"}),": Unlike wheeled robots that maintain continuous contact with the ground, humanoid robots must plan for intermittent foot contact"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Multi-modal movement"}),": Humanoid robots may need to transition between walking, climbing stairs, or even crawling in certain situations"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"key-components-of-nav2-for-humanoid-navigation",children:"Key Components of Nav2 for Humanoid Navigation"}),"\n",(0,i.jsx)(e.p,{children:"The Nav2 stack consists of several key components that work together to enable navigation:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Navigation Server"}),": The central coordinator that manages the navigation pipeline"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Planners"}),": Global and local planners that compute paths and trajectories"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Controllers"}),": Local controllers that execute navigation commands"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Recovery Behaviors"}),": Actions to take when navigation fails or gets stuck"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Transforms"}),": Coordinate frame management for spatial relationships"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"setting-up-nav2-framework-with-ros2-humble",children:"Setting Up Nav2 Framework with ROS2 Humble"}),"\n",(0,i.jsx)(e.p,{children:"Before configuring Nav2 for humanoid navigation, we need to establish the basic Nav2 framework with ROS2 Humble Hawksbill. This foundation will serve as the base for our humanoid-specific adaptations."}),"\n",(0,i.jsx)(e.h3,{id:"installing-nav2-packages",children:"Installing Nav2 Packages"}),"\n",(0,i.jsx)(e.p,{children:"First, ensure that you have ROS2 Humble installed along with the necessary Nav2 packages. If you haven't already installed Nav2, you can do so using the following commands:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"sudo apt update\nsudo apt install ros-humble-navigation2 ros-humble-nav2-bringup ros-humble-nav2-common\nsudo apt install ros-humble-nav2-system-tests ros-humble-nav2-msgs\n"})}),"\n",(0,i.jsx)(e.p,{children:"Additionally, install the Isaac ROS navigation packages that will interface with the Nav2 framework:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"sudo apt install ros-humble-isaac-ros-nav2-interfaces\nsudo apt install ros-humble-isaac-ros-navigation ros-humble-isaac-ros-occupancy-grid-ros\n"})}),"\n",(0,i.jsx)(e.h3,{id:"verifying-nav2-installation",children:"Verifying Nav2 Installation"}),"\n",(0,i.jsx)(e.p,{children:"To verify that Nav2 is properly installed, you can launch the basic Nav2 bringup to ensure all core services are available:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"ros2 launch nav2_bringup tb3_simulation_launch.py headless:=False\n"})}),"\n",(0,i.jsx)(e.p,{children:"This command launches Nav2 in simulation mode, allowing you to verify that all necessary nodes are running correctly. Look for the following key nodes in the terminal output:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"nav2_map_server"}),": Manages map loading and storage"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"nav2_local_costmap_nodes"}),": Handles local obstacle detection"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"nav2_global_costmap_nodes"}),": Manages global costmap representation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"nav2_planner_server"}),": Computes global paths"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"nav2_controller_server"}),": Executes local trajectory control"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"nav2_recoveries_server"}),": Manages recovery behaviors"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"configuring-nav2-for-humanoid-robot-navigation-requirements",children:"Configuring Nav2 for Humanoid Robot Navigation Requirements"}),"\n",(0,i.jsx)(e.p,{children:"Configuring Nav2 for humanoid robots requires significant customization of the default parameters to account for the unique characteristics of bipedal locomotion. Let's explore the key configuration aspects:"}),"\n",(0,i.jsx)(e.h3,{id:"1-costmap-configuration-for-humanoid-form-factor",children:"1. Costmap Configuration for Humanoid Form Factor"}),"\n",(0,i.jsx)(e.p,{children:"The costmap is crucial for navigation as it represents obstacles and navigable space. For humanoid robots, we need to adjust the costmap parameters to reflect the robot's anthropomorphic form factor:"}),"\n",(0,i.jsxs)(e.p,{children:["Create a new configuration file ",(0,i.jsx)(e.code,{children:"humanoid_nav2_params.yaml"})," in your project workspace:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'amcl:\n  ros__parameters:\n    use_sim_time: True\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_footprint"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_delay: 0.5\n    scan_topic: scan\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.5\n    update_min_d: 0.25\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n\namcl_map_client:\n  ros__parameters:\n    use_sim_time: True\n\namcl_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    # Specify the path where the BT XML files are located\n    plugin_lib_names:\n    - nav2_compute_path_to_pose_action_bt_node\n    - nav2_follow_path_action_bt_node\n    - nav2_back_up_action_bt_node\n    - nav2_spin_action_bt_node\n    - nav2_wait_action_bt_node\n    - nav2_clear_costmap_service_bt_node\n    - nav2_is_stuck_condition_bt_node\n    - nav2_goal_reached_condition_bt_node\n    - nav2_initial_pose_received_condition_bt_node\n    - nav2_goal_updated_condition_bt_node\n    - nav2_reinitialize_global_localization_service_bt_node\n    - nav2_rate_controller_bt_node\n    - nav2_distance_controller_bt_node\n    - nav2_speed_controller_bt_node\n    - nav2_truncate_path_action_bt_node\n    - nav2_goal_updater_node_bt_node\n    - nav2_recovery_node_bt_node\n    - nav2_pipeline_sequence_bt_node\n    - nav2_round_robin_node_bt_node\n    - nav2_transform_available_condition_bt_node\n    - nav2_time_expired_condition_bt_node\n    - nav2_path_expiring_timer_condition\n    - nav2_distance_traveled_condition_bt_node\n    - nav2_single_trigger_bt_node\n    - nav2_is_battery_low_condition_bt_node\n    - nav2_navigate_through_poses_action_bt_node\n    - nav2_navigate_to_pose_action_bt_node\n    - nav2_remove_passed_goals_action_bt_node\n    - nav2_planner_selector_bt_node\n    - nav2_controller_selector_bt_node\n    - nav2_goal_checker_selector_bt_node\n\nbt_navigator_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: True\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.001\n    min_theta_velocity_threshold: 0.001\n    # Humanoid-specific controller configuration\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Humanoid-specific velocity limits\n    FollowPath:\n      plugin: "nav2_mppi_controller::MPPIController"\n      time_steps: 32\n      model_dt: 0.05\n      batch_size: 1000\n      vx_std: 0.2\n      vy_std: 0.05\n      wz_std: 0.3\n      vx_max: 0.4      # Reduced for humanoid stability\n      vx_min: -0.2\n      vy_max: 0.2\n      wz_max: 0.5\n      xy_goal_tolerance: 0.2\n      yaw_goal_tolerance: 0.2\n      state_reset_threshold: 0.5\n      control_duration: 0.05\n      transform_tolerance: 0.1\n      heading_scale_factor: 1.0\n      oscillation_score_penalty: 1.0\n      oscillation_magic_number: 4.0\n      oscillation_reset_angle: 0.34\n\ncontroller_server_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: True\n      rolling_window: true\n      width: 6      # Increased for humanoid height awareness\n      height: 6\n      resolution: 0.05\n      robot_radius: 0.4  # Adjusted for humanoid form factor\n      plugins: ["voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: True\n        origin_z: 0.0\n        z_resolution: 0.2\n        z_voxels: 10\n        max_obstacle_height: 2.0  # Humanoid height consideration\n        mark_threshold: 0\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      static_layer:\n        map_subscribe_transient_local: True\n      always_send_full_costmap: True\n  local_costmap_client:\n    ros__parameters:\n      use_sim_time: True\n  local_costmap_rclcpp_node:\n    ros__parameters:\n      use_sim_time: True\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 0.5\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: True\n      robot_radius: 0.4  # Humanoid form factor\n      resolution: 0.05\n      track_unknown_space: true\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: True\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      always_send_full_costmap: True\n  global_costmap_client:\n    ros__parameters:\n      use_sim_time: True\n  global_costmap_rclcpp_node:\n    ros__parameters:\n      use_sim_time: True\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    use_sim_time: True\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner::NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: true\n\nplanner_server_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nrecoveries_server:\n  ros__parameters:\n    costmap_topic: local_costmap/costmap_raw\n    footprint_topic: local_costmap/published_footprint\n    cycle_frequency: 10.0\n    recovery_plugins: ["spin", "backup", "wait"]\n    spin:\n      plugin: "nav2_recoveries::Spin"\n      ideal_linear_velocity: 0.0\n      ideal_angular_velocity: 1.0\n      time_allowance: 5.0\n    backup:\n      plugin: "nav2_recoveries::BackUp"\n      ideal_linear_velocity: -0.1\n      ideal_angular_velocity: 0.0\n      time_allowance: 5.0\n    wait:\n      plugin: "nav2_recoveries::Wait"\n      time_allowance: 5.0\n\nrobot_state_publisher:\n  ros__parameters:\n    use_sim_time: True\n\nwaypoint_follower:\n  ros__parameters:\n    loop_rate: 20\n    stop_on_failure: false\n    waypoint_task_executor_plugin: "wait_at_waypoint"\n    wait_at_waypoint:\n      plugin: "nav2_waypoint_follower::WaitAtWaypoint"\n      enabled: true\n      waypoint_pause_duration: 200\n'})}),"\n",(0,i.jsx)(e.h3,{id:"2-humanoid-specific-navigation-parameters",children:"2. Humanoid-Specific Navigation Parameters"}),"\n",(0,i.jsx)(e.p,{children:"The configuration file above includes several humanoid-specific adjustments:"}),"\n",(0,i.jsx)(e.h4,{id:"velocity-limits",children:"Velocity Limits"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reduced maximum velocities"}),": Humanoid robots typically move slower than wheeled robots for stability"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Careful acceleration profiles"}),": Gradual acceleration/deceleration to maintain balance"]}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"costmap-adjustments",children:"Costmap Adjustments"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Increased robot radius"}),": Accounts for the wider stance and arms of humanoid robots"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Height-aware obstacle detection"}),": Considers obstacles at different heights relevant to humanoid navigation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Larger local costmap window"}),": Provides better awareness of the environment around the humanoid robot"]}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"controller-configuration",children:"Controller Configuration"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"MPPI Controller"}),": Model Predictive Path Integral controller suitable for humanoid dynamics"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Stability-focused parameters"}),": Lower velocity thresholds and conservative control parameters"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"3-launch-configuration-for-humanoid-navigation",children:"3. Launch Configuration for Humanoid Navigation"}),"\n",(0,i.jsxs)(e.p,{children:["Create a launch file ",(0,i.jsx)(e.code,{children:"humanoid_nav2.launch.py"})," that incorporates the humanoid-specific configuration:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import os\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, SetEnvironmentVariable\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom nav2_common.launch import RewrittenYaml\n\n\ndef generate_launch_description():\n    # Get the launch directory\n    bringup_dir = get_package_share_directory('nav2_bringup')\n\n    namespace = LaunchConfiguration('namespace')\n    use_sim_time = LaunchConfiguration('use_sim_time')\n    autostart = LaunchConfiguration('autostart')\n    params_file = LaunchConfiguration('params_file')\n    default_nav_to_pose_bt_xml = LaunchConfiguration('default_nav_to_pose_bt_xml')\n    map_subscribe_transient_local = LaunchConfiguration('map_subscribe_transient_local')\n\n    lifecycle_nodes = ['controller_server',\n                       'smoother_server',\n                       'planner_server',\n                       'behavior_server',\n                       'bt_navigator',\n                       'waypoint_follower']\n\n    remappings = [('/tf', 'tf'),\n                  ('/tf_static', 'tf_static')]\n\n    param_substitutions = {\n        'use_sim_time': use_sim_time,\n        'default_nav_to_pose_bt_xml': default_nav_to_pose_bt_xml,\n        'map_subscribe_transient_local': map_subscribe_transient_local}\n\n    configured_params = RewrittenYaml(\n        source_file=params_file,\n        root_key=namespace,\n        param_rewrites=param_substitutions,\n        convert_types=True)\n\n    return LaunchDescription([\n        # Set environment variables\n        SetEnvironmentVariable('RCUTILS_LOGGING_BUFFERED_STREAM', '1'),\n\n        DeclareLaunchArgument(\n            'namespace', default_value='',\n            description='Top-level namespace'),\n\n        DeclareLaunchArgument(\n            'use_sim_time', default_value='false',\n            description='Use simulation (Gazebo) clock if true'),\n\n        DeclareLaunchArgument(\n            'autostart', default_value='true',\n            description='Automatically startup the nav2 stack'),\n\n        DeclareLaunchArgument(\n            'params_file',\n            default_value=os.path.join(bringup_dir, 'params', 'nav2_params.yaml'),\n            description='Full path to the ROS2 parameters file to use'),\n\n        DeclareLaunchArgument(\n            'default_nav_to_pose_bt_xml',\n            default_value=os.path.join(bringup_dir, 'behavior_trees', 'navigate_to_pose_w_replanning_and_recovery.xml'),\n            description='Full path to the behavior tree xml file to use'),\n\n        DeclareLaunchArgument(\n            'map_subscribe_transient_local', default_value='false',\n            description='Whether to set the map subscriber to transient local'),\n\n        Node(\n            package='nav2_controller',\n            executable='controller_server',\n            output='screen',\n            parameters=[configured_params],\n            remappings=remappings),\n\n        Node(\n            package='nav2_smoother',\n            executable='smoother_server',\n            output='screen',\n            parameters=[configured_params],\n            remappings=remappings),\n\n        Node(\n            package='nav2_planner',\n            executable='planner_server',\n            output='screen',\n            parameters=[configured_params],\n            remappings=remappings),\n\n        Node(\n            package='nav2_behaviors',\n            executable='behavior_server',\n            output='screen',\n            parameters=[configured_params],\n            remappings=remappings),\n\n        Node(\n            package='nav2_bt_navigator',\n            executable='bt_navigator',\n            output='screen',\n            parameters=[configured_params],\n            remappings=remappings),\n\n        Node(\n            package='nav2_waypoint_follower',\n            executable='waypoint_follower',\n            output='screen',\n            parameters=[configured_params],\n            remappings=remappings),\n\n        Node(\n            package='nav2_lifecycle_manager',\n            executable='lifecycle_manager',\n            name='lifecycle_manager_navigation',\n            output='screen',\n            parameters=[{'use_sim_time': use_sim_time},\n                        {'autostart': autostart},\n                        {'node_names': lifecycle_nodes}]),\n    ])\n"})}),"\n",(0,i.jsx)(e.h2,{id:"adapting-path-planning-for-bipedal-locomotion-constraints",children:"Adapting Path Planning for Bipedal Locomotion Constraints"}),"\n",(0,i.jsx)(e.p,{children:"Path planning for humanoid robots must account for the unique constraints of bipedal locomotion. Unlike wheeled robots that can turn in place, humanoid robots must plan paths that accommodate their walking gait and balance requirements."}),"\n",(0,i.jsx)(e.h3,{id:"understanding-bipedal-locomotion-constraints",children:"Understanding Bipedal Locomotion Constraints"}),"\n",(0,i.jsx)(e.p,{children:"Bipedal locomotion introduces several constraints that affect path planning:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Step-by-step movement"}),": Humanoid robots must place each foot in a stable position before moving the other"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Balance maintenance"}),": Paths must allow for maintaining center of mass within the support polygon"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Turning radius"}),": Humans have a minimum turning radius based on leg length and stride"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Terrain considerations"}),": Uneven surfaces, stairs, and obstacles require special navigation strategies"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"modifying-planner-parameters",children:"Modifying Planner Parameters"}),"\n",(0,i.jsx)(e.p,{children:"To address these constraints, we need to modify the planner server configuration to incorporate humanoid-specific path planning requirements:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'planner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    use_sim_time: True\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner::NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: true\n      # Humanoid-specific path smoothing\n      smooth_path: true\n      # Minimum distance between waypoints for humanoid gait\n      minimum_turning_radius: 0.3  # meters\n      # Path optimization for humanoid step planning\n      step_size: 0.1              # Distance between path points for humanoid\n      max_iterations: 10000       # Allow more iterations for complex humanoid paths\n'})}),"\n",(0,i.jsx)(e.h3,{id:"implementing-custom-path-smoothing-for-humanoid-movement",children:"Implementing Custom Path Smoothing for Humanoid Movement"}),"\n",(0,i.jsx)(e.p,{children:"For humanoid robots, we need smoother paths that account for the natural gait pattern. Create a custom path smoother that generates waypoints suitable for bipedal locomotion:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'// humanoid_path_smoother.cpp\n#include "nav2_core/path_smoother.hpp"\n#include "nav2_util/geometry_utils.hpp"\n#include "nav2_costmap_2d/cost_values.hpp"\n#include <vector>\n#include <cmath>\n\nnamespace nav2_smoother\n{\n\nclass HumanoidPathSmoother : public nav2_core::PathSmoother\n{\npublic:\n  void configure(\n    const rclcpp_lifecycle::LifecycleNode::WeakPtr & node,\n    std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros,\n    const std::string & plugin_name) override\n  {\n    node_ = node;\n    costmap_ros_ = costmap_ros;\n    plugin_name_ = plugin_name;\n\n    // Get humanoid-specific parameters\n    auto node_shared = node_.lock();\n    node_shared->get_parameter_or(plugin_name + ".smoothing_num_samples", smoothing_num_samples_, 5);\n    node_shared->get_parameter_or(plugin_name + ".smoothing_step_size", smoothing_step_size_, 0.1);\n    node_shared->get_parameter_or(plugin_name + ".max_deviation", max_deviation_, 0.5);\n  }\n\n  void cleanup() override {}\n\n  void activate() override {}\n\n  void deactivate() override {}\n\n  nav_msgs::msg::Path smooth(const nav_msgs::msg::Path & path) override\n  {\n    nav_msgs::msg::Path smoothed_path;\n\n    if (path.poses.empty()) {\n      return smoothed_path;\n    }\n\n    // Start with the original path\n    smoothed_path.header = path.header;\n\n    // Apply humanoid-specific smoothing algorithm\n    std::vector<geometry_msgs::msg::PoseStamped> intermediate_poses;\n\n    for (size_t i = 0; i < path.poses.size() - 1; ++i) {\n      const auto & start_pose = path.poses[i];\n      const auto & end_pose = path.poses[i + 1];\n\n      // Calculate distance between poses\n      double dx = end_pose.pose.position.x - start_pose.pose.position.x;\n      double dy = end_pose.pose.position.y - start_pose.pose.position.y;\n      double distance = std::sqrt(dx * dx + dy * dy);\n\n      // Interpolate poses at humanoid-appropriate intervals\n      int num_intermediate_points = static_cast<int>(distance / smoothing_step_size_);\n\n      for (int j = 0; j <= num_intermediate_points; ++j) {\n        geometry_msgs::msg::PoseStamped intermediate_pose;\n        intermediate_pose.header = path.header;\n\n        double ratio = static_cast<double>(j) / num_intermediate_points;\n\n        // Linear interpolation for position\n        intermediate_pose.pose.position.x =\n          start_pose.pose.position.x + ratio * (end_pose.pose.position.x - start_pose.pose.position.x);\n        intermediate_pose.pose.position.y =\n          start_pose.pose.position.y + ratio * (end_pose.pose.position.y - start_pose.pose.position.y);\n\n        // Maintain orientation (heading toward next point)\n        if (j < num_intermediate_points) {\n          double angle = std::atan2(\n            end_pose.pose.position.y - intermediate_pose.pose.position.y,\n            end_pose.pose.position.x - intermediate_pose.pose.position.x\n          );\n\n          intermediate_pose.pose.orientation =\n            nav2_util::geometry_utils::orientationAroundZAxis(angle);\n        } else {\n          // Use original orientation for the last point\n          intermediate_pose.pose.orientation = end_pose.pose.orientation;\n        }\n\n        intermediate_poses.push_back(intermediate_pose);\n      }\n    }\n\n    // Apply deviation constraints to ensure path stays close to original\n    std::vector<geometry_msgs::msg::PoseStamped> constrained_poses;\n    for (const auto & pose : intermediate_poses) {\n      if (isValidHumanoidPose(pose)) {\n        constrained_poses.push_back(pose);\n      }\n    }\n\n    smoothed_path.poses = constrained_poses;\n    return smoothed_path;\n  }\n\nprivate:\n  bool isValidHumanoidPose(const geometry_msgs::msg::PoseStamped & pose)\n  {\n    // Check if the pose is valid for humanoid navigation\n    unsigned int mx, my;\n    auto costmap = costmap_ros_->getCostmap();\n\n    if (!costmap->worldToMap(pose.pose.position.x, pose.pose.position.y, mx, my)) {\n      return false;  // Pose outside of costmap bounds\n    }\n\n    unsigned char cost = costmap->getCost(mx, my);\n\n    // Humanoid robots need more clearance due to arm swing and balance\n    return cost != nav2_costmap_2d::LETHAL_OBSTACLE &&\n           cost != nav2_costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n  }\n\n  rclcpp_lifecycle::WeakPtr node_;\n  std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros_;\n  std::string plugin_name_;\n\n  int smoothing_num_samples_{5};\n  double smoothing_step_size_{0.1};  // Humanoid-appropriate step size\n  double max_deviation_{0.5};\n};\n\n}  // namespace nav2_smoother\n\n#include "pluginlib/class_list_macros.hpp"\nPLUGINLIB_EXPORT_CLASS(nav2_smoother::HumanoidPathSmoother, nav2_core::PathSmoother)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"collision-avoidance-for-humanoid-form-factor",children:"Collision Avoidance for Humanoid Form Factor"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots require specialized collision avoidance due to their anthropomorphic form factor. The collision avoidance system must consider not only the robot's base but also its extended limbs and height."}),"\n",(0,i.jsx)(e.h4,{id:"height-aware-collision-detection",children:"Height-Aware Collision Detection"}),"\n",(0,i.jsx)(e.p,{children:"Configure the obstacle layer to consider obstacles at different heights relevant to humanoid robots:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'local_costmap:\n  local_costmap:\n    ros__parameters:\n      # ... existing parameters ...\n      plugins: ["voxel_layer", "inflation_layer"]\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: True\n        origin_z: 0.0\n        z_resolution: 0.1  # Higher resolution for height awareness\n        z_voxels: 20       # Account for humanoid height\n        max_obstacle_height: 2.0  # Humanoid height consideration\n        # ... other voxel layer parameters ...\n'})}),"\n",(0,i.jsx)(e.h4,{id:"dynamic-footprint-for-bipedal-walking",children:"Dynamic Footprint for Bipedal Walking"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots have a dynamic footprint that changes as they walk. Implement a dynamic footprint that updates based on the robot's walking state:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'// dynamic_humanoid_footprint.cpp\n#include "rclcpp/rclcpp.hpp"\n#include "geometry_msgs/msg/polygon_stamped.hpp"\n#include "sensor_msgs/msg/laser_scan.hpp"\n#include "tf2/LinearMath/Quaternion.h"\n#include "tf2_geometry_msgs/tf2_geometry_msgs.hpp"\n\nclass DynamicHumanoidFootprint : public rclcpp::Node\n{\npublic:\n  DynamicHumanoidFootprint() : Node("dynamic_humanoid_footprint")\n  {\n    footprint_pub_ = this->create_publisher<geometry_msgs::msg::PolygonStamped>(\n      "humanoid_footprint", 1);\n\n    odom_sub_ = this->create_subscription<nav_msgs::msg::Odometry>(\n      "odom", 10,\n      std::bind(&DynamicHumanoidFootprint::odometryCallback, this, std::placeholders::_1));\n\n    // Initialize the default humanoid footprint (larger than typical wheeled robots)\n    initializeDefaultFootprint();\n\n    timer_ = this->create_wall_timer(\n      std::chrono::milliseconds(100),\n      std::bind(&DynamicHumanoidFootprint::publishFootprint, this));\n  }\n\nprivate:\n  void odometryCallback(const nav_msgs::msg::Odometry::SharedPtr msg)\n  {\n    // Extract walking state information from odometry\n    // This could come from joint angles, IMU data, or gait phase estimation\n\n    // For now, we\'ll use a simplified approach based on velocity\n    double linear_vel = std::sqrt(\n      msg->twist.twist.linear.x * msg->twist.twist.linear.x +\n      msg->twist.twist.linear.y * msg->twist.twist.linear.y);\n\n    // Adjust footprint based on walking state\n    if (linear_vel > 0.01) {\n      // Robot is moving - expand footprint to account for dynamic stability\n      adjustFootprintForWalking();\n    } else {\n      // Robot is stationary - use default footprint\n      current_footprint_ = default_footprint_;\n    }\n  }\n\n  void initializeDefaultFootprint()\n  {\n    // Define a default humanoid footprint (larger than typical robots)\n    geometry_msgs::msg::Point32 pt;\n\n    // Create a rectangular footprint accounting for humanoid width\n    // Front part (where feet would be when walking forward)\n    pt.x = 0.3; pt.y = 0.25;  // Front-right corner\n    default_footprint_.points.push_back(pt);\n    pt.x = 0.3; pt.y = -0.25; // Front-left corner\n    default_footprint_.points.push_back(pt);\n    pt.x = -0.1; pt.y = -0.25; // Rear-left corner\n    default_footprint_.points.push_back(pt);\n    pt.x = -0.1; pt.y = 0.25;  // Rear-right corner\n    default_footprint_.points.push_back(pt);\n  }\n\n  void adjustFootprintForWalking()\n  {\n    // Expand footprint when walking to account for:\n    // - Arm swing during walking\n    // - Dynamic stability margins\n    // - Potential balance corrections\n\n    current_footprint_ = default_footprint_;\n\n    // Increase the footprint size during walking\n    for (auto& point : current_footprint_.points) {\n      point.x *= 1.2;  // 20% expansion in X direction\n      point.y *= 1.2;  // 20% expansion in Y direction\n    }\n  }\n\n  void publishFootprint()\n  {\n    geometry_msgs::msg::PolygonStamped footprint_msg;\n    footprint_msg.header.frame_id = "base_footprint";\n    footprint_msg.header.stamp = this->now();\n    footprint_msg.polygon = current_footprint_;\n\n    footprint_pub_->publish(footprint_msg);\n  }\n\n  rclcpp::Publisher<geometry_msgs::msg::PolygonStamped>::SharedPtr footprint_pub_;\n  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;\n  rclcpp::TimerBase::SharedPtr timer_;\n\n  geometry_msgs::msg::Polygon default_footprint_;\n  geometry_msgs::msg::Polygon current_footprint_;\n};\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n  rclcpp::spin(std::make_shared<DynamicHumanoidFootprint>());\n  rclcpp::shutdown();\n  return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"testing-navigation-in-isaac-sim-environment",children:"Testing Navigation in Isaac Sim Environment"}),"\n",(0,i.jsx)(e.p,{children:"Now that we've configured Nav2 for humanoid navigation, let's test it in the Isaac Sim environment. This will validate that our configurations work properly in a realistic simulation environment."}),"\n",(0,i.jsx)(e.h3,{id:"setting-up-isaac-sim-for-humanoid-navigation",children:"Setting Up Isaac Sim for Humanoid Navigation"}),"\n",(0,i.jsx)(e.p,{children:"First, ensure that your Isaac Sim environment is properly configured for humanoid navigation testing:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Source your ROS2 workspace\nsource install/setup.bash\n\n# Launch Isaac Sim with humanoid navigation scene\n./isaaclaunch.sh -p IsaacExamples/python/nav2_humanoid_example.py\n"})}),"\n",(0,i.jsx)(e.h3,{id:"creating-a-navigation-test-script",children:"Creating a Navigation Test Script"}),"\n",(0,i.jsx)(e.p,{children:"Create a Python script to test the navigation capabilities with your humanoid robot:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped\nfrom nav2_msgs.action import NavigateToPose\nfrom rclpy.action import ActionClient\nimport time\n\n\nclass HumanoidNavigator(Node):\n    def __init__(self):\n        super().__init__('humanoid_navigator')\n\n        # Create action client for navigation\n        self._action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\n\n        # Timer to periodically send navigation goals\n        self.timer = self.create_timer(10.0, self.send_navigation_goal)\n        self.goal_count = 0\n\n    def send_navigation_goal(self):\n        \"\"\"Send a navigation goal to the humanoid robot\"\"\"\n        # Wait for the action server to be available\n        if not self._action_client.wait_for_server(timeout_sec=1.0):\n            self.get_logger().error('Navigation action server not available')\n            return\n\n        # Create a navigation goal\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n\n        # Define a sequence of goals to test navigation\n        goals = [\n            {'x': 2.0, 'y': 2.0, 'theta': 0.0},\n            {'x': -1.0, 'y': 3.0, 'theta': 1.57},\n            {'x': -2.0, 'y': -1.0, 'theta': 3.14},\n            {'x': 1.0, 'y': -2.0, 'theta': -1.57}\n        ]\n\n        if self.goal_count >= len(goals):\n            self.goal_count = 0\n\n        current_goal = goals[self.goal_count]\n\n        goal_msg.pose.pose.position.x = current_goal['x']\n        goal_msg.pose.pose.position.y = current_goal['y']\n        goal_msg.pose.pose.position.z = 0.0\n\n        # Convert angle to quaternion\n        from math import sin, cos\n        theta = current_goal['theta']\n        goal_msg.pose.pose.orientation.z = sin(theta / 2.0)\n        goal_msg.pose.pose.orientation.w = cos(theta / 2.0)\n\n        # Send the goal\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n        self.get_logger().info(f'Sent navigation goal {self.goal_count + 1}: '\n                              f'({current_goal[\"x\"]}, {current_goal[\"y\"]})')\n\n        self.goal_count += 1\n\n    def goal_response_callback(self, future):\n        \"\"\"Handle the response from the navigation server\"\"\"\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected')\n            return\n\n        self.get_logger().info('Goal accepted')\n\n        # Get result callback\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        \"\"\"Handle the result of the navigation\"\"\"\n        result = future.result().result\n        self.get_logger().info(f'Navigation result: {result}')\n\n    def feedback_callback(self, feedback_msg):\n        \"\"\"Handle feedback during navigation\"\"\"\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f'Navigation progress: {feedback.distance_remaining:.2f}m remaining')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    navigator = HumanoidNavigator()\n\n    try:\n        rclpy.spin(navigator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        navigator.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(e.h3,{id:"validating-path-planning-for-bipedal-locomotion",children:"Validating Path Planning for Bipedal Locomotion"}),"\n",(0,i.jsx)(e.p,{children:"Create a validation script to verify that the path planning works correctly for bipedal locomotion:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Path\nfrom geometry_msgs.msg import PoseStamped\nimport numpy as np\nfrom scipy.spatial.distance import euclidean\n\n\nclass BipedalPathValidator(Node):\n    def __init__(self):\n        super().__init__('bipedal_path_validator')\n\n        # Subscribe to the planned path\n        self.path_sub = self.create_subscription(\n            Path, '/plan', self.path_callback, 10)\n\n        # Parameters for validation\n        self.min_step_distance = 0.1  # Minimum distance between path points (humanoid step size)\n        self.max_deviation = 0.5      # Maximum deviation from straight line\n        self.turning_radius = 0.3     # Minimum turning radius for humanoid\n\n        self.get_logger().info('Bipedal Path Validator initialized')\n\n    def path_callback(self, msg):\n        \"\"\"Validate the received path for humanoid compatibility\"\"\"\n        if len(msg.poses) < 2:\n            return\n\n        path_valid = True\n        violations = []\n\n        # Check step distances\n        for i in range(len(msg.poses) - 1):\n            pos1 = msg.poses[i].pose.position\n            pos2 = msg.poses[i + 1].pose.position\n\n            distance = euclidean([pos1.x, pos1.y], [pos2.x, pos2.y])\n\n            if distance < self.min_step_distance:\n                violations.append(f'Step {i} too short: {distance:.3f}m (min: {self.min_step_distance}m)')\n                path_valid = False\n            elif distance > 0.5:  # Reasonable upper bound for humanoid steps\n                violations.append(f'Step {i} too long: {distance:.3f}m (max: 0.5m)')\n                path_valid = False\n\n        # Check for excessive deviations\n        if len(msg.poses) >= 3:\n            for i in range(1, len(msg.poses) - 1):\n                pos_prev = msg.poses[i - 1].pose.position\n                pos_curr = msg.poses[i].pose.position\n                pos_next = msg.poses[i + 1].pose.position\n\n                # Calculate deviation from straight line\n                line_vec = np.array([pos_next.x - pos_prev.x, pos_next.y - pos_prev.y])\n                point_vec = np.array([pos_curr.x - pos_prev.x, pos_curr.y - pos_prev.y])\n\n                # Project point onto line\n                line_len = np.linalg.norm(line_vec)\n                if line_len > 0:\n                    projection = np.dot(point_vec, line_vec) / (line_len * line_len) * line_vec\n                    deviation = np.linalg.norm(point_vec - projection)\n\n                    if deviation > self.max_deviation:\n                        violations.append(f'Excessive deviation at point {i}: {deviation:.3f}m (max: {self.max_deviation}m)')\n                        path_valid = False\n\n        # Log validation results\n        if path_valid:\n            self.get_logger().info(f'Path validation passed: {len(msg.poses)} waypoints')\n        else:\n            self.get_logger().warn(f'Path validation failed with {len(violations)} violations:')\n            for violation in violations:\n                self.get_logger().warn(f'  - {violation}')\n\n    def calculate_curvature(self, path_poses):\n        \"\"\"Calculate curvature of the path to ensure it meets turning radius requirements\"\"\"\n        if len(path_poses) < 3:\n            return []\n\n        curvatures = []\n        for i in range(1, len(path_poses) - 1):\n            p1 = np.array([path_poses[i-1].pose.position.x, path_poses[i-1].pose.position.y])\n            p2 = np.array([path_poses[i].pose.position.x, path_poses[i].pose.position.y])\n            p3 = np.array([path_poses[i+1].pose.position.x, path_poses[i+1].pose.position.y])\n\n            # Calculate vectors\n            v1 = p2 - p1\n            v2 = p3 - p2\n\n            # Calculate angle between vectors\n            cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n            angle = np.arccos(np.clip(cos_angle, -1, 1))\n\n            # Curvature is inverse of turning radius\n            curvature = angle / np.linalg.norm(v1)  # Simplified curvature calculation\n            curvatures.append(curvature)\n\n        return curvatures\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    validator = BipedalPathValidator()\n\n    try:\n        rclpy.spin(validator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        validator.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(e.h2,{id:"integration-with-isaac-ros-packages",children:"Integration with Isaac ROS Packages"}),"\n",(0,i.jsx)(e.p,{children:"To fully leverage the NVIDIA Isaac ecosystem, we need to integrate our Nav2 configuration with Isaac ROS packages for enhanced perception and navigation capabilities."}),"\n",(0,i.jsx)(e.h3,{id:"isaac-ros-perception-integration",children:"Isaac ROS Perception Integration"}),"\n",(0,i.jsx)(e.p,{children:"Integrate Isaac ROS perception packages to enhance the navigation system with hardware-accelerated sensing:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'# Add Isaac ROS perception integration to your configuration\nisaac_ros_perception:\n  ros__parameters:\n    # Stereo camera configuration for depth perception\n    left_topic: "/stereo_left/image_rect_color"\n    right_topic: "/stereo_right/image_rect_color"\n    left_camera_info_topic: "/stereo_left/camera_info"\n    right_camera_info_topic: "/stereo_right/camera_info"\n\n    # Processing parameters\n    disparity_range: 64\n    correlation_window_size: 49\n    texture_threshold: 10\n    uniqueness_ratio: 15\n\n    # Output configuration\n    disparity_topic: "/disparity"\n    pointcloud_topic: "/points2"\n'})}),"\n",(0,i.jsx)(e.h3,{id:"isaac-ros-navigation-integration",children:"Isaac ROS Navigation Integration"}),"\n",(0,i.jsx)(e.p,{children:"Configure Isaac ROS navigation packages to work with Nav2:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'# Isaac ROS navigation integration\nisaac_ros_navigation:\n  ros__parameters:\n    # Navigation parameters\n    enable_visualization: true\n    visualization_rate: 10.0\n\n    # Integration with Nav2\n    nav2_integration_enabled: true\n    nav2_costmap_topic: "/global_costmap/costmap"\n\n    # Hardware acceleration\n    gpu_processing_enabled: true\n    cuda_device_id: 0\n'})}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"In this lesson, we've successfully configured Nav2 path planning specifically adapted for humanoid robots. We covered:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Nav2 Framework Setup"}),": Installed and verified Nav2 with ROS2 Humble for humanoid navigation requirements"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Humanoid-Specific Configuration"}),": Adapted navigation parameters for bipedal locomotion constraints and humanoid robot kinematics"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Path Planning Adaptation"}),": Modified planner parameters to accommodate humanoid movement patterns"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Collision Avoidance"}),": Implemented collision avoidance systems considering the humanoid form factor"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Testing and Validation"}),": Tested navigation in Isaac Sim environment and validated path planning for bipedal locomotion"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Isaac ROS Integration"}),": Integrated with Isaac ROS packages for enhanced perception and navigation capabilities"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"The configuration we've developed addresses the unique challenges of humanoid navigation, including balance maintenance, anthropomorphic form factor considerations, and bipedal locomotion constraints. The system is now ready to serve as the foundation for advanced navigation capabilities in subsequent lessons."}),"\n",(0,i.jsx)(e.p,{children:"In the next lesson, we'll explore Visual SLAM with Isaac ROS, building upon this navigation foundation to enable real-time localization and mapping capabilities for humanoid robots."})]})}function d(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>s,x:()=>r});var o=a(6540);const i={},t=o.createContext(i);function s(n){const e=o.useContext(t);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),o.createElement(t.Provider,{value:e},n.children)}}}]);