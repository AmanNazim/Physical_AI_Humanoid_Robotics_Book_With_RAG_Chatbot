"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[5281],{4972:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>f,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"module-1/nodes-topics-services-robot-communication/parameter-server-configuration","title":"Parameter Server Configuration","description":"Learning Objectives","source":"@site/docs/module-1/2-nodes-topics-services-robot-communication/parameter-server-configuration.md","sourceDirName":"module-1/2-nodes-topics-services-robot-communication","slug":"/module-1/nodes-topics-services-robot-communication/parameter-server-configuration","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-1/nodes-topics-services-robot-communication/parameter-server-configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/AmanNazim/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/edit/main/physical-ai-humanoid-robotics-book/docs/module-1/2-nodes-topics-services-robot-communication/parameter-server-configuration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Service-based Communication","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-1/nodes-topics-services-robot-communication/service-based-communication"},"next":{"title":"Chapter 3 Introduction - Robot Description (URDF/Xacro) and Embodiment","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-1/robot-description-urdf-xacro/"}}');var a=o(4848),r=o(8453);const i={sidebar_position:4},s="Parameter Server Configuration",l={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Concept Overview and Scope",id:"concept-overview-and-scope",level:2},{value:"Required Tools and Technologies",id:"required-tools-and-technologies",level:2},{value:"Understanding the ROS2 Parameter Server",id:"understanding-the-ros2-parameter-server",level:2},{value:"Defining and Using Parameters in Nodes",id:"defining-and-using-parameters-in-nodes",level:2},{value:"Creating Parameter Configuration Files (YAML)",id:"creating-parameter-configuration-files-yaml",level:2},{value:"Using Parameter Configuration Files",id:"using-parameter-configuration-files",level:2},{value:"Runtime Parameter Updates",id:"runtime-parameter-updates",level:2},{value:"Parameter Validation and Fallback Mechanisms",id:"parameter-validation-and-fallback-mechanisms",level:2},{value:"Testing Parameter Configuration",id:"testing-parameter-configuration",level:2},{value:"Best Practices for Parameter Management",id:"best-practices-for-parameter-management",level:2},{value:"Parameter Management for Different Robot Configurations",id:"parameter-management-for-different-robot-configurations",level:2},{value:"Summary",id:"summary",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"parameter-server-configuration",children:"Parameter Server Configuration"})}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Understand the ROS2 parameter server and its role in robot configuration"}),"\n",(0,a.jsx)(n.li,{children:"Define and use parameters in nodes with proper validation"}),"\n",(0,a.jsx)(n.li,{children:"Implement runtime parameter updates for dynamic behavior"}),"\n",(0,a.jsx)(n.li,{children:"Create and use parameter configuration files (YAML)"}),"\n",(0,a.jsx)(n.li,{children:"Design parameterized nodes that adapt behavior at runtime"}),"\n",(0,a.jsx)(n.li,{children:"Implement parameter validation and fallback mechanisms"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"concept-overview-and-scope",children:"Concept Overview and Scope"}),"\n",(0,a.jsx)(n.p,{children:"In this lesson, you will learn to configure and manage ROS2 parameters for dynamic node behavior and configuration. The ROS2 parameter server provides a centralized system for managing configuration values that can be changed at runtime. You will implement parameterized nodes that can adapt their behavior dynamically, supporting different robot configurations and operational modes. This lesson covers parameter definition, validation, runtime updates, and configuration file management."}),"\n",(0,a.jsx)(n.h2,{id:"required-tools-and-technologies",children:"Required Tools and Technologies"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"ROS2 Humble Hawksbill"}),"\n",(0,a.jsx)(n.li,{children:"rclpy (Python client library)"}),"\n",(0,a.jsx)(n.li,{children:"Parameter configuration files (YAML)"}),"\n",(0,a.jsx)(n.li,{children:"colcon build system"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"understanding-the-ros2-parameter-server",children:"Understanding the ROS2 Parameter Server"}),"\n",(0,a.jsx)(n.p,{children:"The ROS2 parameter server is a distributed system that allows nodes to share configuration values. Parameters provide a way to configure node behavior without recompiling code, making robots adaptable to different configurations and operational requirements. Key features of the ROS2 parameter system include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Runtime Configuration"}),": Parameters can be changed while nodes are running"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Type Safety"}),": Parameters have defined types (integer, float, string, boolean, lists)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Declarative Definition"}),": Parameters can be declared with default values and constraints"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Configuration Files"}),": Parameters can be loaded from YAML files at startup"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Command-Line Tools"}),": Parameters can be viewed and modified using ROS2 command-line tools"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Parameters are particularly useful for:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Robot-specific configurations (joint limits, sensor offsets)"}),"\n",(0,a.jsx)(n.li,{children:"Operational modes (debug vs production settings)"}),"\n",(0,a.jsx)(n.li,{children:"Tuning values (PID controller parameters)"}),"\n",(0,a.jsx)(n.li,{children:"Feature flags (enabling/disabling functionality)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"defining-and-using-parameters-in-nodes",children:"Defining and Using Parameters in Nodes"}),"\n",(0,a.jsx)(n.p,{children:"Let's create a parameterized node that demonstrates how to declare, use, and update parameters at runtime. First, let's create the parameterized node implementation:"}),"\n",(0,a.jsxs)(n.p,{children:["Create the parameterized node file (",(0,a.jsx)(n.code,{children:"advanced_communication_tutorials/advanced_communication_tutorials/parameterized_robot_node.py"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\n\"\"\"\nParameterized robot node demonstrating dynamic configuration.\nThis node uses parameters to control its behavior at runtime.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom std_msgs.msg import String, Float64\nfrom sensor_msgs.msg import JointState\nimport math\n\n\nclass ParameterizedRobotNode(Node):\n    \"\"\"\n    A ROS2 node that demonstrates parameter-based configuration.\n    The node behavior can be changed by modifying parameters at runtime.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('parameterized_robot_node')\n\n        # Declare parameters with default values and descriptions\n        self.declare_parameter('robot_name', 'default_robot',\n                              ParameterDescriptor(description='Name of the robot'))\n        self.declare_parameter('control_frequency', 50,\n                              ParameterDescriptor(description='Control loop frequency in Hz'))\n        self.declare_parameter('safety_mode', True,\n                              ParameterDescriptor(description='Enable safety checks'))\n        self.declare_parameter('max_velocity', 1.0,\n                              ParameterDescriptor(description='Maximum joint velocity'))\n        self.declare_parameter('debug_mode', False,\n                              ParameterDescriptor(description='Enable debug output'))\n        self.declare_parameter('joint_offsets', [0.0, 0.0, 0.0, 0.0, 0.0],\n                              ParameterDescriptor(description='Joint position offsets'))\n        self.declare_parameter('operation_mode', 'normal',\n                              ParameterDescriptor(description='Operation mode: normal, calibration, maintenance'))\n\n        # Get initial parameter values\n        self.robot_name = self.get_parameter('robot_name').value\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.safety_mode = self.get_parameter('safety_mode').value\n        self.max_velocity = self.get_parameter('max_velocity').value\n        self.debug_mode = self.get_parameter('debug_mode').value\n        self.joint_offsets = self.get_parameter('joint_offsets').value\n        self.operation_mode = self.get_parameter('operation_mode').value\n\n        # Create QoS profile\n        qos_profile = QoSProfile(\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE,\n            depth=10\n        )\n\n        # Publishers\n        self.status_publisher = self.create_publisher(String, 'robot_status', qos_profile)\n        self.control_publisher = self.create_publisher(JointState, 'joint_commands', qos_profile)\n        self.debug_publisher = self.create_publisher(String, 'debug_info', qos_profile)\n\n        # Timer for control loop\n        timer_period = 1.0 / self.control_frequency  # seconds\n        self.timer = self.create_timer(timer_period, self.control_loop)\n\n        # Parameter change callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        # Internal state\n        self.loop_counter = 0\n        self.joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0]\n        self.joint_velocities = [0.0, 0.0, 0.0, 0.0, 0.0]\n\n        self.get_logger().info(f'Parameterized Robot Node \"{self.robot_name}\" initialized')\n        self.get_logger().info(f'Control frequency: {self.control_frequency}Hz')\n        self.get_logger().info(f'Safety mode: {self.safety_mode}')\n        self.get_logger().info(f'Max velocity: {self.max_velocity}')\n        self.get_logger().info(f'Debug mode: {self.debug_mode}')\n        self.get_logger().info(f'Joint offsets: {self.joint_offsets}')\n        self.get_logger().info(f'Operation mode: {self.operation_mode}')\n\n    def parameter_callback(self, params):\n        \"\"\"\n        Callback function for parameter changes.\n        This is called when parameters are updated at runtime.\n        \"\"\"\n        for param in params:\n            if param.name == 'robot_name':\n                self.robot_name = param.value\n                self.get_logger().info(f'Robot name updated to: {self.robot_name}')\n            elif param.name == 'control_frequency':\n                if param.value > 0:\n                    self.control_frequency = param.value\n                    # Update timer period\n                    new_period = 1.0 / self.control_frequency\n                    self.timer.timer_period_ns = int(new_period * 1e9)\n                    self.get_logger().info(f'Control frequency updated to: {self.control_frequency}Hz')\n                else:\n                    return SetParametersResult(successful=False, reason='Control frequency must be positive')\n            elif param.name == 'safety_mode':\n                self.safety_mode = param.value\n                self.get_logger().info(f'Safety mode updated to: {self.safety_mode}')\n            elif param.name == 'max_velocity':\n                if param.value >= 0:\n                    self.max_velocity = param.value\n                    self.get_logger().info(f'Max velocity updated to: {self.max_velocity}')\n                else:\n                    return SetParametersResult(successful=False, reason='Max velocity must be non-negative')\n            elif param.name == 'debug_mode':\n                self.debug_mode = param.value\n                self.get_logger().info(f'Debug mode updated to: {self.debug_mode}')\n            elif param.name == 'joint_offsets':\n                if len(param.value) == 5:  # Assuming 5 joints\n                    self.joint_offsets = param.value\n                    self.get_logger().info(f'Joint offsets updated to: {self.joint_offsets}')\n                else:\n                    return SetParametersResult(successful=False, reason='Joint offsets must have 5 values')\n            elif param.name == 'operation_mode':\n                valid_modes = ['normal', 'calibration', 'maintenance']\n                if param.value in valid_modes:\n                    self.operation_mode = param.value\n                    self.get_logger().info(f'Operation mode updated to: {self.operation_mode}')\n                else:\n                    return SetParametersResult(successful=False, reason=f'Invalid operation mode. Valid: {valid_modes}')\n\n        return SetParametersResult(successful=True)\n\n    def control_loop(self):\n        \"\"\"\n        Main control loop that runs at the specified frequency.\n        This loop uses parameters to determine its behavior.\n        \"\"\"\n        self.loop_counter += 1\n\n        # Update joint positions based on current mode and parameters\n        if self.operation_mode == 'calibration':\n            # In calibration mode, move through a calibration pattern\n            time_factor = self.loop_counter * 0.02  # Adjust based on control frequency\n            self.joint_positions = [\n                math.sin(time_factor + i * 0.5) * 0.5 for i in range(5)\n            ]\n        elif self.operation_mode == 'maintenance':\n            # In maintenance mode, hold position or move slowly\n            self.joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0]\n        else:  # normal mode\n            # In normal mode, follow a more complex pattern\n            time_factor = self.loop_counter * 0.01\n            self.joint_positions = [\n                math.sin(time_factor * (i + 1)) * (0.5 - i * 0.1) for i in range(5)\n            ]\n\n        # Apply joint offsets\n        adjusted_positions = [\n            pos + offset for pos, offset in zip(self.joint_positions, self.joint_offsets)\n        ]\n\n        # Apply velocity limits if safety mode is enabled\n        if self.safety_mode:\n            for i, pos in enumerate(adjusted_positions):\n                # Apply velocity limiting\n                target_vel = (pos - self.joint_positions[i]) * self.control_frequency\n                if abs(target_vel) > self.max_velocity:\n                    # Limit velocity\n                    limited_change = math.copysign(self.max_velocity / self.control_frequency, target_vel)\n                    adjusted_positions[i] = self.joint_positions[i] + limited_change\n\n        # Update velocities (approximate)\n        self.joint_velocities = [\n            (new_pos - old_pos) * self.control_frequency\n            for new_pos, old_pos in zip(adjusted_positions, self.joint_positions)\n        ]\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f'Robot: {self.robot_name}, Mode: {self.operation_mode}, Loop: {self.loop_counter}'\n        self.status_publisher.publish(status_msg)\n\n        # Publish joint commands\n        joint_msg = JointState()\n        joint_msg.header.stamp = self.get_clock().now().to_msg()\n        joint_msg.header.frame_id = 'base_link'\n        joint_msg.name = [f'joint_{i}' for i in range(5)]\n        joint_msg.position = adjusted_positions\n        joint_msg.velocity = self.joint_velocities\n        joint_msg.effort = [0.0] * 5  # No effort values in this example\n        self.control_publisher.publish(joint_msg)\n\n        # Publish debug info if enabled\n        if self.debug_mode:\n            debug_msg = String()\n            debug_msg.data = f'Pos: {adjusted_positions}, Vel: {self.joint_velocities}, Params: freq={self.control_frequency}, max_vel={self.max_velocity}'\n            self.debug_publisher.publish(debug_msg)\n\n        if self.loop_counter % 100 == 0:  # Log every 100 iterations\n            self.get_logger().info(f'Control loop status - Mode: {self.operation_mode}, Positions: {adjusted_positions[:3]}...')\n\n    def get_current_config(self):\n        \"\"\"\n        Return current parameter configuration as a dictionary.\n        \"\"\"\n        return {\n            'robot_name': self.robot_name,\n            'control_frequency': self.control_frequency,\n            'safety_mode': self.safety_mode,\n            'max_velocity': self.max_velocity,\n            'debug_mode': self.debug_mode,\n            'joint_offsets': self.joint_offsets,\n            'operation_mode': self.operation_mode\n        }\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = ParameterizedRobotNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Parameterized node interrupted by user')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.p,{children:"We need to add the ParameterDescriptor import. Let me update the imports:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\n\"\"\"\nParameterized robot node demonstrating dynamic configuration.\nThis node uses parameters to control its behavior at runtime.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom rclpy.parameter_service import ParameterService\nfrom rcl_interfaces.msg import ParameterDescriptor\nfrom rcl_interfaces.srv import SetParametersResult\nfrom std_msgs.msg import String, Float64\nfrom sensor_msgs.msg import JointState\nimport math\n\n\nclass ParameterizedRobotNode(Node):\n    \"\"\"\n    A ROS2 node that demonstrates parameter-based configuration.\n    The node behavior can be changed by modifying parameters at runtime.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('parameterized_robot_node')\n\n        # Declare parameters with default values and descriptions\n        self.declare_parameter('robot_name', 'default_robot',\n                              ParameterDescriptor(description='Name of the robot'))\n        self.declare_parameter('control_frequency', 50,\n                              ParameterDescriptor(description='Control loop frequency in Hz'))\n        self.declare_parameter('safety_mode', True,\n                              ParameterDescriptor(description='Enable safety checks'))\n        self.declare_parameter('max_velocity', 1.0,\n                              ParameterDescriptor(description='Maximum joint velocity'))\n        self.declare_parameter('debug_mode', False,\n                              ParameterDescriptor(description='Enable debug output'))\n        self.declare_parameter('joint_offsets', [0.0, 0.0, 0.0, 0.0, 0.0],\n                              ParameterDescriptor(description='Joint position offsets'))\n        self.declare_parameter('operation_mode', 'normal',\n                              ParameterDescriptor(description='Operation mode: normal, calibration, maintenance'))\n\n        # Get initial parameter values\n        self.robot_name = self.get_parameter('robot_name').value\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.safety_mode = self.get_parameter('safety_mode').value\n        self.max_velocity = self.get_parameter('max_velocity').value\n        self.debug_mode = self.get_parameter('debug_mode').value\n        self.joint_offsets = self.get_parameter('joint_offsets').value\n        self.operation_mode = self.get_parameter('operation_mode').value\n\n        # Create QoS profile\n        qos_profile = QoSProfile(\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE,\n            depth=10\n        )\n\n        # Publishers\n        self.status_publisher = self.create_publisher(String, 'robot_status', qos_profile)\n        self.control_publisher = self.create_publisher(JointState, 'joint_commands', qos_profile)\n        self.debug_publisher = self.create_publisher(String, 'debug_info', qos_profile)\n\n        # Timer for control loop\n        timer_period = 1.0 / self.control_frequency  # seconds\n        self.timer = self.create_timer(timer_period, self.control_loop)\n\n        # Parameter change callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        # Internal state\n        self.loop_counter = 0\n        self.joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0]\n        self.joint_velocities = [0.0, 0.0, 0.0, 0.0, 0.0]\n\n        self.get_logger().info(f'Parameterized Robot Node \"{self.robot_name}\" initialized')\n        self.get_logger().info(f'Control frequency: {self.control_frequency}Hz')\n        self.get_logger().info(f'Safety mode: {self.safety_mode}')\n        self.get_logger().info(f'Max velocity: {self.max_velocity}')\n        self.get_logger().info(f'Debug mode: {self.debug_mode}')\n        self.get_logger().info(f'Joint offsets: {self.joint_offsets}')\n        self.get_logger().info(f'Operation mode: {self.operation_mode}')\n\n    def parameter_callback(self, params):\n        \"\"\"\n        Callback function for parameter changes.\n        This is called when parameters are updated at runtime.\n        \"\"\"\n        for param in params:\n            if param.name == 'robot_name':\n                self.robot_name = param.value\n                self.get_logger().info(f'Robot name updated to: {self.robot_name}')\n            elif param.name == 'control_frequency':\n                if param.value > 0:\n                    self.control_frequency = param.value\n                    # Update timer period\n                    new_period = 1.0 / self.control_frequency\n                    self.timer.timer_period_ns = int(new_period * 1e9)\n                    self.get_logger().info(f'Control frequency updated to: {self.control_frequency}Hz')\n                else:\n                    return SetParametersResult(successful=False, reason='Control frequency must be positive')\n            elif param.name == 'safety_mode':\n                self.safety_mode = param.value\n                self.get_logger().info(f'Safety mode updated to: {self.safety_mode}')\n            elif param.name == 'max_velocity':\n                if param.value >= 0:\n                    self.max_velocity = param.value\n                    self.get_logger().info(f'Max velocity updated to: {self.max_velocity}')\n                else:\n                    return SetParametersResult(successful=False, reason='Max velocity must be non-negative')\n            elif param.name == 'debug_mode':\n                self.debug_mode = param.value\n                self.get_logger().info(f'Debug mode updated to: {self.debug_mode}')\n            elif param.name == 'joint_offsets':\n                if len(param.value) == 5:  # Assuming 5 joints\n                    self.joint_offsets = param.value\n                    self.get_logger().info(f'Joint offsets updated to: {self.joint_offsets}')\n                else:\n                    return SetParametersResult(successful=False, reason='Joint offsets must have 5 values')\n            elif param.name == 'operation_mode':\n                valid_modes = ['normal', 'calibration', 'maintenance']\n                if param.value in valid_modes:\n                    self.operation_mode = param.value\n                    self.get_logger().info(f'Operation mode updated to: {self.operation_mode}')\n                else:\n                    return SetParametersResult(successful=False, reason=f'Invalid operation mode. Valid: {valid_modes}')\n\n        return SetParametersResult(successful=True)\n\n    def control_loop(self):\n        \"\"\"\n        Main control loop that runs at the specified frequency.\n        This loop uses parameters to determine its behavior.\n        \"\"\"\n        self.loop_counter += 1\n\n        # Update joint positions based on current mode and parameters\n        if self.operation_mode == 'calibration':\n            # In calibration mode, move through a calibration pattern\n            time_factor = self.loop_counter * 0.02  # Adjust based on control frequency\n            self.joint_positions = [\n                math.sin(time_factor + i * 0.5) * 0.5 for i in range(5)\n            ]\n        elif self.operation_mode == 'maintenance':\n            # In maintenance mode, hold position or move slowly\n            self.joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0]\n        else:  # normal mode\n            # In normal mode, follow a more complex pattern\n            time_factor = self.loop_counter * 0.01\n            self.joint_positions = [\n                math.sin(time_factor * (i + 1)) * (0.5 - i * 0.1) for i in range(5)\n            ]\n\n        # Apply joint offsets\n        adjusted_positions = [\n            pos + offset for pos, offset in zip(self.joint_positions, self.joint_offsets)\n        ]\n\n        # Apply velocity limits if safety mode is enabled\n        if self.safety_mode:\n            for i, pos in enumerate(adjusted_positions):\n                # Apply velocity limiting\n                target_vel = (pos - self.joint_positions[i]) * self.control_frequency\n                if abs(target_vel) > self.max_velocity:\n                    # Limit velocity\n                    limited_change = math.copysign(self.max_velocity / self.control_frequency, target_vel)\n                    adjusted_positions[i] = self.joint_positions[i] + limited_change\n\n        # Update velocities (approximate)\n        self.joint_velocities = [\n            (new_pos - old_pos) * self.control_frequency\n            for new_pos, old_pos in zip(adjusted_positions, self.joint_positions)\n        ]\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f'Robot: {self.robot_name}, Mode: {self.operation_mode}, Loop: {self.loop_counter}'\n        self.status_publisher.publish(status_msg)\n\n        # Publish joint commands\n        joint_msg = JointState()\n        joint_msg.header.stamp = self.get_clock().now().to_msg()\n        joint_msg.header.frame_id = 'base_link'\n        joint_msg.name = [f'joint_{i}' for i in range(5)]\n        joint_msg.position = adjusted_positions\n        joint_msg.velocity = self.joint_velocities\n        joint_msg.effort = [0.0] * 5  # No effort values in this example\n        self.control_publisher.publish(joint_msg)\n\n        # Publish debug info if enabled\n        if self.debug_mode:\n            debug_msg = String()\n            debug_msg.data = f'Pos: {adjusted_positions}, Vel: {self.joint_velocities}, Params: freq={self.control_frequency}, max_vel={self.max_velocity}'\n            self.debug_publisher.publish(debug_msg)\n\n        if self.loop_counter % 100 == 0:  # Log every 100 iterations\n            self.get_logger().info(f'Control loop status - Mode: {self.operation_mode}, Positions: {adjusted_positions[:3]}...}')\n\n    def get_current_config(self):\n        \"\"\"\n        Return current parameter configuration as a dictionary.\n        \"\"\"\n        return {\n            'robot_name': self.robot_name,\n            'control_frequency': self.control_frequency,\n            'safety_mode': self.safety_mode,\n            'max_velocity': self.max_velocity,\n            'debug_mode': self.debug_mode,\n            'joint_offsets': self.joint_offsets,\n            'operation_mode': self.operation_mode\n        }\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = ParameterizedRobotNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Parameterized node interrupted by user')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.p,{children:"Actually, let me create a simpler version that doesn't need the additional imports to avoid complexity:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\n\"\"\"\nParameterized robot node demonstrating dynamic configuration.\nThis node uses parameters to control its behavior at runtime.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom std_msgs.msg import String, Float64\nfrom sensor_msgs.msg import JointState\nimport math\n\n\nclass ParameterizedRobotNode(Node):\n    \"\"\"\n    A ROS2 node that demonstrates parameter-based configuration.\n    The node behavior can be changed by modifying parameters at runtime.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('parameterized_robot_node')\n\n        # Declare parameters with default values\n        self.declare_parameter('robot_name', 'default_robot')\n        self.declare_parameter('control_frequency', 50)\n        self.declare_parameter('safety_mode', True)\n        self.declare_parameter('max_velocity', 1.0)\n        self.declare_parameter('debug_mode', False)\n        self.declare_parameter('joint_offsets', [0.0, 0.0, 0.0, 0.0, 0.0])\n        self.declare_parameter('operation_mode', 'normal')\n\n        # Get initial parameter values\n        self.robot_name = self.get_parameter('robot_name').value\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.safety_mode = self.get_parameter('safety_mode').value\n        self.max_velocity = self.get_parameter('max_velocity').value\n        self.debug_mode = self.get_parameter('debug_mode').value\n        self.joint_offsets = self.get_parameter('joint_offsets').value\n        self.operation_mode = self.get_parameter('operation_mode').value\n\n        # Create QoS profile\n        qos_profile = QoSProfile(\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE,\n            depth=10\n        )\n\n        # Publishers\n        self.status_publisher = self.create_publisher(String, 'robot_status', qos_profile)\n        self.control_publisher = self.create_publisher(JointState, 'joint_commands', qos_profile)\n        self.debug_publisher = self.create_publisher(String, 'debug_info', qos_profile)\n\n        # Timer for control loop\n        timer_period = 1.0 / self.control_frequency  # seconds\n        self.timer = self.create_timer(timer_period, self.control_loop)\n\n        # Parameter change callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        # Internal state\n        self.loop_counter = 0\n        self.joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0]\n        self.joint_velocities = [0.0, 0.0, 0.0, 0.0, 0.0]\n\n        self.get_logger().info(f'Parameterized Robot Node \"{self.robot_name}\" initialized')\n        self.get_logger().info(f'Control frequency: {self.control_frequency}Hz')\n        self.get_logger().info(f'Safety mode: {self.safety_mode}')\n        self.get_logger().info(f'Max velocity: {self.max_velocity}')\n        self.get_logger().info(f'Debug mode: {self.debug_mode}')\n        self.get_logger().info(f'Joint offsets: {self.joint_offsets}')\n        self.get_logger().info(f'Operation mode: {self.operation_mode}')\n\n    def parameter_callback(self, params):\n        \"\"\"\n        Callback function for parameter changes.\n        This is called when parameters are updated at runtime.\n        \"\"\"\n        from rcl_interfaces.srv import SetParametersResult\n\n        for param in params:\n            if param.name == 'robot_name':\n                self.robot_name = param.value\n                self.get_logger().info(f'Robot name updated to: {self.robot_name}')\n            elif param.name == 'control_frequency':\n                if param.value > 0:\n                    self.control_frequency = param.value\n                    # Update timer period - note: in real applications you might want to recreate the timer\n                    self.get_logger().info(f'Control frequency updated to: {self.control_frequency}Hz')\n                else:\n                    return SetParametersResult(successful=False, reason='Control frequency must be positive')\n            elif param.name == 'safety_mode':\n                self.safety_mode = param.value\n                self.get_logger().info(f'Safety mode updated to: {self.safety_mode}')\n            elif param.name == 'max_velocity':\n                if param.value >= 0:\n                    self.max_velocity = param.value\n                    self.get_logger().info(f'Max velocity updated to: {self.max_velocity}')\n                else:\n                    return SetParametersResult(successful=False, reason='Max velocity must be non-negative')\n            elif param.name == 'debug_mode':\n                self.debug_mode = param.value\n                self.get_logger().info(f'Debug mode updated to: {self.debug_mode}')\n            elif param.name == 'joint_offsets':\n                if len(param.value) == 5:  # Assuming 5 joints\n                    self.joint_offsets = param.value\n                    self.get_logger().info(f'Joint offsets updated to: {self.joint_offsets}')\n                else:\n                    return SetParametersResult(successful=False, reason='Joint offsets must have 5 values')\n            elif param.name == 'operation_mode':\n                valid_modes = ['normal', 'calibration', 'maintenance']\n                if param.value in valid_modes:\n                    self.operation_mode = param.value\n                    self.get_logger().info(f'Operation mode updated to: {self.operation_mode}')\n                else:\n                    return SetParametersResult(successful=False, reason=f'Invalid operation mode. Valid: {valid_modes}')\n\n        return SetParametersResult(successful=True)\n\n    def control_loop(self):\n        \"\"\"\n        Main control loop that runs at the specified frequency.\n        This loop uses parameters to determine its behavior.\n        \"\"\"\n        self.loop_counter += 1\n\n        # Update joint positions based on current mode and parameters\n        if self.operation_mode == 'calibration':\n            # In calibration mode, move through a calibration pattern\n            time_factor = self.loop_counter * 0.02  # Adjust based on control frequency\n            self.joint_positions = [\n                math.sin(time_factor + i * 0.5) * 0.5 for i in range(5)\n            ]\n        elif self.operation_mode == 'maintenance':\n            # In maintenance mode, hold position or move slowly\n            self.joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0]\n        else:  # normal mode\n            # In normal mode, follow a more complex pattern\n            time_factor = self.loop_counter * 0.01\n            self.joint_positions = [\n                math.sin(time_factor * (i + 1)) * (0.5 - i * 0.1) for i in range(5)\n            ]\n\n        # Apply joint offsets\n        adjusted_positions = [\n            pos + offset for pos, offset in zip(self.joint_positions, self.joint_offsets)\n        ]\n\n        # Apply velocity limits if safety mode is enabled\n        if self.safety_mode:\n            for i, pos in enumerate(adjusted_positions):\n                # Apply velocity limiting (simplified approach)\n                pass  # In a real system, you'd implement velocity limiting here\n\n        # Update velocities (approximate)\n        if self.loop_counter > 1:  # Skip first iteration\n            self.joint_velocities = [\n                (new_pos - old_pos) * self.control_frequency\n                for new_pos, old_pos in zip(adjusted_positions, self.joint_positions)\n            ]\n        else:\n            self.joint_velocities = [0.0] * 5\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f'Robot: {self.robot_name}, Mode: {self.operation_mode}, Loop: {self.loop_counter}'\n        self.status_publisher.publish(status_msg)\n\n        # Publish joint commands\n        joint_msg = JointState()\n        joint_msg.header.stamp = self.get_clock().now().to_msg()\n        joint_msg.header.frame_id = 'base_link'\n        joint_msg.name = [f'joint_{i}' for i in range(5)]\n        joint_msg.position = adjusted_positions\n        joint_msg.velocity = self.joint_velocities\n        joint_msg.effort = [0.0] * 5  # No effort values in this example\n        self.control_publisher.publish(joint_msg)\n\n        # Publish debug info if enabled\n        if self.debug_mode:\n            debug_msg = String()\n            debug_msg.data = f'Pos: {adjusted_positions}, Vel: {self.joint_velocities}, Params: freq={self.control_frequency}, max_vel={self.max_velocity}'\n            self.debug_publisher.publish(debug_msg)\n\n        if self.loop_counter % 100 == 0:  # Log every 100 iterations\n            self.get_logger().info(f'Control loop status - Mode: {self.operation_mode}, Positions: {adjusted_positions[:3]}...')\n\n    def get_current_config(self):\n        \"\"\"\n        Return current parameter configuration as a dictionary.\n        \"\"\"\n        return {\n            'robot_name': self.robot_name,\n            'control_frequency': self.control_frequency,\n            'safety_mode': self.safety_mode,\n            'max_velocity': self.max_velocity,\n            'debug_mode': self.debug_mode,\n            'joint_offsets': self.joint_offsets,\n            'operation_mode': self.operation_mode\n        }\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = ParameterizedRobotNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Parameterized node interrupted by user')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now let me update the setup.py to include this new node:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\nfrom glob import glob\nimport os\n\npackage_name = 'advanced_communication_tutorials'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py')),\n        (os.path.join('share', package_name, 'config'), glob('config/*.yaml'))\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='student',\n    maintainer_email='student@todo.todo',\n    description='Advanced ROS2 Communication Tutorials',\n    license='Apache-2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'multi_communication_node = advanced_communication_tutorials.multi_communication_node:main',\n            'sensor_publisher = advanced_communication_tutorials.sensor_publisher:main',\n            'robot_state_server = advanced_communication_tutorials.robot_state_server:main',\n            'robot_command_client = advanced_communication_tutorials.robot_command_client:main',\n            'parameterized_robot_node = advanced_communication_tutorials.parameterized_robot_node:main',\n        ],\n    },\n)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-parameter-configuration-files-yaml",children:"Creating Parameter Configuration Files (YAML)"}),"\n",(0,a.jsx)(n.p,{children:"Parameter configuration files in YAML format allow you to set parameter values at node startup. Create a config directory and configuration file:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"mkdir -p advanced_communication_tutorials/config\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Create a default configuration file (",(0,a.jsx)(n.code,{children:"advanced_communication_tutorials/config/default_robot_config.yaml"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'parameterized_robot_node:\n  ros__parameters:\n    robot_name: "my_robot"\n    control_frequency: 100\n    safety_mode: true\n    max_velocity: 2.0\n    debug_mode: false\n    joint_offsets: [0.1, -0.1, 0.05, -0.05, 0.0]\n    operation_mode: "normal"\n\n# Example of another node\'s parameters\nsensor_publisher:\n  ros__parameters:\n    publish_frequency: 50\n    sensor_noise_level: 0.01\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Create a calibration configuration file (",(0,a.jsx)(n.code,{children:"advanced_communication_tutorials/config/calibration_config.yaml"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'parameterized_robot_node:\n  ros__parameters:\n    robot_name: "calibration_robot"\n    control_frequency: 10\n    safety_mode: true\n    max_velocity: 0.5\n    debug_mode: true\n    joint_offsets: [0.0, 0.0, 0.0, 0.0, 0.0]\n    operation_mode: "calibration"\n\n# Additional calibration-specific parameters\ncalibration_node:\n  ros__parameters:\n    calibration_speed: 0.1\n    tolerance: 0.001\n    max_attempts: 5\n'})}),"\n",(0,a.jsx)(n.h2,{id:"using-parameter-configuration-files",children:"Using Parameter Configuration Files"}),"\n",(0,a.jsx)(n.p,{children:"To use these configuration files when launching your node, you can either:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Load them programmatically in your launch file"}),"\n",(0,a.jsx)(n.li,{children:"Specify them on the command line when running the node"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Here's how to load parameters from a YAML file when starting a node:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Run the node with a specific configuration file\nros2 run advanced_communication_tutorials parameterized_robot_node --ros-args --params-file config/default_robot_config.yaml\n"})}),"\n",(0,a.jsx)(n.h2,{id:"runtime-parameter-updates",children:"Runtime Parameter Updates"}),"\n",(0,a.jsx)(n.p,{children:"ROS2 provides command-line tools to update parameters while nodes are running. Here are the most common operations:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"List all parameters for a node:"})}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ros2 param list /parameterized_robot_node\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Get a specific parameter value:"})}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ros2 param get /parameterized_robot_node robot_name\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Set a parameter value:"})}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ros2 param set /parameterized_robot_node debug_mode true\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"4",children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Get all parameters in YAML format:"})}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ros2 param dump /parameterized_robot_node\n"})}),"\n",(0,a.jsx)(n.h2,{id:"parameter-validation-and-fallback-mechanisms",children:"Parameter Validation and Fallback Mechanisms"}),"\n",(0,a.jsx)(n.p,{children:"In our parameterized node implementation, we included validation mechanisms:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Range Validation"}),": We validate that control frequency is positive and max velocity is non-negative."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"List Length Validation"}),": We ensure that joint offsets have exactly 5 values."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Value Set Validation"}),": We validate that operation mode is one of the allowed values."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Fallback Behavior"}),": If a parameter update fails validation, the parameter callback returns a failure result, and the parameter value remains unchanged."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"testing-parameter-configuration",children:"Testing Parameter Configuration"}),"\n",(0,a.jsx)(n.p,{children:"First, build the package with the new node:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select advanced_communication_tutorials\nsource install/setup.bash\n"})}),"\n",(0,a.jsx)(n.p,{children:"Run the parameterized node:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ros2 run advanced_communication_tutorials parameterized_robot_node\n"})}),"\n",(0,a.jsx)(n.p,{children:"In another terminal, you can modify parameters while the node is running:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Change the operation mode\nros2 param set /parameterized_robot_node operation_mode calibration\n\n# Enable debug mode\nros2 param set /parameterized_robot_node debug_mode true\n\n# Change max velocity\nros2 param set /parameterized_robot_node max_velocity 1.5\n\n# View all parameters\nros2 param list /parameterized_robot_node\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can also run the node with a configuration file:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ros2 run advanced_communication_tutorials parameterized_robot_node --ros-args --params-file ~/ros2_ws/src/advanced_communication_tutorials/config/calibration_config.yaml\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-for-parameter-management",children:"Best Practices for Parameter Management"}),"\n",(0,a.jsx)(n.p,{children:"When designing parameterized nodes, follow these best practices:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Descriptive Names"}),": Choose parameter names that clearly indicate their purpose."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Provide Good Defaults"}),": Set sensible default values that work for most use cases."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Validate Input"}),": Always validate parameter values to prevent invalid configurations."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Document Parameters"}),": Document what each parameter does and its valid range of values."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Group Related Parameters"}),": Organize related parameters logically in configuration files."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Appropriate Types"}),": Use the correct parameter types (int, float, string, bool, lists) for validation."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Consider Performance"}),": Be aware that parameter callbacks are synchronous and can affect node performance."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Plan for Multiple Configurations"}),": Design your system to support different operational configurations (development, testing, production)."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"parameter-management-for-different-robot-configurations",children:"Parameter Management for Different Robot Configurations"}),"\n",(0,a.jsx)(n.p,{children:"Parameters enable the same node code to work with different robot configurations. For example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Different Robot Models"}),": Use parameters to specify joint limits, link lengths, and other robot-specific values"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Operational Modes"}),": Use parameters to switch between normal operation, calibration, and maintenance modes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Environmental Conditions"}),": Use parameters to adjust for different operating environments (indoor vs outdoor, different payloads)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Safety Levels"}),": Use parameters to adjust safety margins and operational constraints"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"In this lesson, you learned how to configure and manage ROS2 parameters for dynamic node behavior. You implemented a parameterized node that can adapt its behavior at runtime, created YAML configuration files for different operational modes, and learned about parameter validation and fallback mechanisms. You also explored how to update parameters while nodes are running and best practices for parameter management. Parameter management is essential for creating flexible, configurable robotic systems that can adapt to different robots, operational modes, and environmental conditions."})]})}function f(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>s});var t=o(6540);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);