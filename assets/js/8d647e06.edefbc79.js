"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[9575],{7318:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2/Physics-&-Sensors/lesson-2.1-physics-simulation-fundamentals","title":"Lesson 2.1 \u2013 Physics Simulation Fundamentals","description":"Learning Objectives","source":"@site/docs/module-2/02-Physics-&-Sensors/lesson-2.1-physics-simulation-fundamentals.md","sourceDirName":"module-2/02-Physics-&-Sensors","slug":"/module-2/Physics-&-Sensors/lesson-2.1-physics-simulation-fundamentals","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-2/Physics-&-Sensors/lesson-2.1-physics-simulation-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/AmanNazim/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/edit/main/physical-ai-humanoid-robotics-book/docs/module-2/02-Physics-&-Sensors/lesson-2.1-physics-simulation-fundamentals.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Lesson 2.1 \u2013 Physics Simulation Fundamentals","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2 \u2013 Physics & Sensors","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-2/Physics-&-Sensors/"},"next":{"title":"Lesson 2.2 \u2013 LiDAR Simulation in Virtual Environments","permalink":"/Physical_AI_Humanoid_Robotics_Book_With_RAG_Chatbot/docs/module-2/Physics-&-Sensors/lesson-2.2-lidar-simulation-in-virtual-environments"}}');var o=i(4848),t=i(8453);const r={title:"Lesson 2.1 \u2013 Physics Simulation Fundamentals",sidebar_position:3},a="Lesson 2.1 \u2013 Physics Simulation Fundamentals",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Physics Simulation",id:"introduction-to-physics-simulation",level:2},{value:"Physics Parameters Configuration",id:"physics-parameters-configuration",level:2},{value:"Gravity Configuration",id:"gravity-configuration",level:3},{value:"Friction Parameters",id:"friction-parameters",level:3},{value:"Collision Detection Settings",id:"collision-detection-settings",level:3},{value:"Material Properties",id:"material-properties",level:3},{value:"Setting Up Physics Configuration in Gazebo",id:"setting-up-physics-configuration-in-gazebo",level:2},{value:"Step 1: Create a Custom Physics Configuration File",id:"step-1-create-a-custom-physics-configuration-file",level:3},{value:"Step 2: Configure Physics Parameters",id:"step-2-configure-physics-parameters",level:3},{value:"Step 3: Launch Gazebo with Custom Physics",id:"step-3-launch-gazebo-with-custom-physics",level:3},{value:"Testing Physics Behavior with Different Parameters",id:"testing-physics-behavior-with-different-parameters",level:2},{value:"Experiment 1: Varying Gravity Values",id:"experiment-1-varying-gravity-values",level:3},{value:"Experiment 2: Testing Friction Effects",id:"experiment-2-testing-friction-effects",level:3},{value:"Validating Physics Simulation Accuracy",id:"validating-physics-simulation-accuracy",level:2},{value:"Method 1: Comparing with Real-World Physics",id:"method-1-comparing-with-real-world-physics",level:3},{value:"Method 2: Using Built-in Gazebo Tools",id:"method-2-using-built-in-gazebo-tools",level:3},{value:"Method 3: Creating Validation Scripts",id:"method-3-creating-validation-scripts",level:3},{value:"Different Physics Engines Comparison",id:"different-physics-engines-comparison",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet",id:"bullet",level:3},{value:"DART",id:"dart",level:3},{value:"Practical Exercise: Configuring Physics for Your Humanoid Robot",id:"practical-exercise-configuring-physics-for-your-humanoid-robot",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"lesson-21--physics-simulation-fundamentals",children:"Lesson 2.1 \u2013 Physics Simulation Fundamentals"})}),"\n",(0,o.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Configure physics parameters for realistic simulation including gravity, friction, collision detection, and material properties"}),"\n",(0,o.jsx)(n.li,{children:"Understand physics engines and their application to humanoid robotics"}),"\n",(0,o.jsx)(n.li,{children:"Test physics behavior with different parameter settings"}),"\n",(0,o.jsx)(n.li,{children:"Validate physics simulation accuracy against real-world expectations"}),"\n",(0,o.jsx)(n.li,{children:"Work with different physics engines (ODE, Bullet, DART) in Gazebo"}),"\n",(0,o.jsx)(n.li,{children:"Create and modify physics configuration files with realistic parameters"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-physics-simulation",children:"Introduction to Physics Simulation"}),"\n",(0,o.jsx)(n.p,{children:"Physics simulation is the cornerstone of any realistic robotic simulation environment. In the context of humanoid robotics, accurate physics simulation ensures that the robot behaves naturally when interacting with its environment. This includes realistic movement, balance, collision responses, and environmental interactions."}),"\n",(0,o.jsx)(n.p,{children:"Gazebo provides three different physics engines that can be used for simulating physical interactions:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ODE (Open Dynamics Engine)"}),": The default physics engine, widely used and stable"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Bullet"}),": Offers advanced collision detection and constraint solving"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"}),": Provides robust and accurate physics simulation"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Each engine has its strengths and is suitable for different types of simulations. Understanding these differences will help you choose the right engine for your specific humanoid robotics applications."}),"\n",(0,o.jsx)(n.h2,{id:"physics-parameters-configuration",children:"Physics Parameters Configuration"}),"\n",(0,o.jsx)(n.h3,{id:"gravity-configuration",children:"Gravity Configuration"}),"\n",(0,o.jsx)(n.p,{children:"Gravity is a fundamental parameter that affects all objects in the simulation. By default, Gazebo uses Earth's gravity value of 9.8 m/s\xb2, but this can be adjusted for different scenarios (e.g., moon simulation with 1.62 m/s\xb2)."}),"\n",(0,o.jsxs)(n.p,{children:["To configure gravity, you'll need to modify the physics configuration file. Create or update the ",(0,o.jsx)(n.code,{children:"physics.world"})," file in your simulation directory:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.7">\n  <world name="default">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode" enabled="true">\n      \x3c!-- Gravity vector: x, y, z components in m/s^2 --\x3e\n      <gravity>0 0 -9.8</gravity>\n\n      \x3c!-- ODE-specific parameters --\x3e\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0.0</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Rest of your world configuration --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"friction-parameters",children:"Friction Parameters"}),"\n",(0,o.jsx)(n.p,{children:"Friction determines how objects interact when they come into contact with surfaces. There are two main types of friction coefficients:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Static Friction"}),": Resistance to initial motion"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic Friction"}),": Resistance during sliding motion"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These parameters are typically defined in the material properties of your robot's links:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example of friction configuration in a URDF/SDF model --\x3e\n<link name="foot_link">\n  <collision name="foot_collision">\n    <geometry>\n      <box>\n        <size>0.1 0.08 0.02</size>\n      </box>\n    </geometry>\n    <surface>\n      <friction>\n        <ode>\n          <mu>0.7</mu>       \x3c!-- Static friction coefficient --\x3e\n          <mu2>0.7</mu2>     \x3c!-- Dynamic friction coefficient --\x3e\n          <slip1>0.0</slip1> \x3c!-- Slip coefficient 1 --\x3e\n          <slip2>0.0</slip2> \x3c!-- Slip coefficient 2 --\x3e\n        </ode>\n      </friction>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"collision-detection-settings",children:"Collision Detection Settings"}),"\n",(0,o.jsx)(n.p,{children:"Collision detection is critical for preventing objects from passing through each other. The parameters control the precision and performance of collision detection:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<collision name="collision_name">\n  <geometry>\n    \x3c!-- Geometry definition --\x3e\n  </geometry>\n  <surface>\n    <contact>\n      <ode>\n        <soft_cfm>0.0</soft_cfm>\n        <soft_erp>0.2</soft_erp>\n        <kp>1e+13</kp>        \x3c!-- Contact stiffness --\x3e\n        <kd>1.0</kd>          \x3c!-- Damping coefficient --\x3e\n        <max_vel>100.0</max_vel>\n        <min_depth>0.001</min_depth>\n      </ode>\n    </contact>\n  </surface>\n</collision>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"material-properties",children:"Material Properties"}),"\n",(0,o.jsx)(n.p,{children:"Material properties define how surfaces interact with each other. These include bounciness (restitution coefficient) and other surface characteristics:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<surface>\n  <bounce>\n    <restitution_coefficient>0.1</restitution_coefficient>\n    <threshold>100000.0</threshold>\n  </bounce>\n</surface>\n"})}),"\n",(0,o.jsx)(n.h2,{id:"setting-up-physics-configuration-in-gazebo",children:"Setting Up Physics Configuration in Gazebo"}),"\n",(0,o.jsx)(n.h3,{id:"step-1-create-a-custom-physics-configuration-file",children:"Step 1: Create a Custom Physics Configuration File"}),"\n",(0,o.jsx)(n.p,{children:"First, let's create a physics configuration file that will be used in your simulation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Create a directory for physics configurations\nmkdir -p ~/humanoid_robot_ws/src/humanoid_robot_simulation/config/physics\n\n# Create the physics configuration file\ntouch ~/humanoid_robot_ws/src/humanoid_robot_simulation/config/physics/humanoid_physics.sdf\n"})}),"\n",(0,o.jsx)(n.h3,{id:"step-2-configure-physics-parameters",children:"Step 2: Configure Physics Parameters"}),"\n",(0,o.jsxs)(n.p,{children:["Add the following content to your ",(0,o.jsx)(n.code,{children:"humanoid_physics.sdf"})," file:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.7">\n  <world name="humanoid_world">\n    <physics type="ode" enabled="true" default="true">\n      \x3c!-- Standard Earth gravity --\x3e\n      <gravity>0 0 -9.8</gravity>\n\n      \x3c!-- ODE Solver Configuration --\x3e\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>100</iters>              \x3c!-- Number of iterations --\x3e\n          <sor>1.3</sor>                  \x3c!-- Successive over-relaxation parameter --\x3e\n        </solver>\n\n        \x3c!-- Constraints Configuration --\x3e\n        <constraints>\n          <cfm>0.0</cfm>                  \x3c!-- Constraint Force Mixing parameter --\x3e\n          <erp>0.2</erp>                  \x3c!-- Error Reduction Parameter --\x3e\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Optional: Include a ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Optional: Include sky --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"step-3-launch-gazebo-with-custom-physics",children:"Step 3: Launch Gazebo with Custom Physics"}),"\n",(0,o.jsx)(n.p,{children:"To launch Gazebo with your custom physics configuration, create a launch file:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In your launch directory, create gazebo_physics.launch --\x3e\n<launch>\n  <arg name="world_name" default="$(find humanoid_robot_simulation)/config/physics/humanoid_physics.sdf"/>\n\n  <include file="$(find gazebo_ros)/launch/empty_world.launch">\n    <arg name="world_name" value="$(arg world_name)"/>\n    <arg name="paused" value="false"/>\n    <arg name="use_sim_time" value="true"/>\n    <arg name="gui" value="true"/>\n    <arg name="headless" value="false"/>\n    <arg name="debug" value="false"/>\n  </include>\n</launch>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"testing-physics-behavior-with-different-parameters",children:"Testing Physics Behavior with Different Parameters"}),"\n",(0,o.jsx)(n.h3,{id:"experiment-1-varying-gravity-values",children:"Experiment 1: Varying Gravity Values"}),"\n",(0,o.jsx)(n.p,{children:"Let's create a simple test to observe how different gravity values affect robot behavior:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'# Create a simple test script\ncat << \'EOF\' > ~/humanoid_robot_ws/src/humanoid_robot_simulation/test/gravity_test.sh\n#!/bin/bash\n\necho "Testing different gravity values..."\n\n# Create a temporary world file with low gravity (moon-like)\ncat << \'WORLD\' > /tmp/moon_gravity.sdf\n<?xml version="1.0"?>\n<sdf version="1.7">\n  <world name="moon_world">\n    <physics type="ode" enabled="true">\n      <gravity>0 0 -1.62</gravity>  \x3c!-- Moon gravity --\x3e\n      <ode>\n        <solver><type>quick</type><iters>100</iters><sor>1.3</sor></solver>\n        <constraints><cfm>0.0</cfm><erp>0.2</erp></constraints>\n      </ode>\n    </physics>\n    <include><uri>model://ground_plane</uri></include>\n    <include><uri>model://sun</uri></include>\n  </world>\n</sdf>\nWORLD\n\n# Create a temporary world file with high gravity\ncat << \'WORLD\' > /tmp/high_gravity.sdf\n<?xml version="1.0"?>\n<sdf version="1.7">\n  <world name="high_gravity_world">\n    <physics type="ode" enabled="true">\n      <gravity>0 0 -20.0</gravity>  \x3c!-- Very high gravity --\x3e\n      <ode>\n        <solver><type>quick</type><iters>100</iters><sor>1.3</sor></solver>\n        <constraints><cfm>0.0</cfm><erp>0.2</erp></constraints>\n      </ode>\n    </physics>\n    <include><uri>model://ground_plane</uri></include>\n    <include><uri>model://sun</uri></include>\n  </world>\n</sdf>\nWORLD\n\necho "Created temporary world files for testing:"\necho "  - Moon gravity: /tmp/moon_gravity.sdf"\necho "  - High gravity: /tmp/high_gravity.sdf"\nEOF\n\nchmod +x ~/humanoid_robot_ws/src/humanoid_robot_simulation/test/gravity_test.sh\n'})}),"\n",(0,o.jsx)(n.h3,{id:"experiment-2-testing-friction-effects",children:"Experiment 2: Testing Friction Effects"}),"\n",(0,o.jsx)(n.p,{children:"To test friction effects, we'll create a simple slope model:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Create a friction_test.sdf file --\x3e\n<?xml version="1.0"?>\n<sdf version="1.7">\n  <model name="slope_test">\n    <pose>0 0 0 0 0 0</pose>\n\n    \x3c!-- Slope base --\x3e\n    <link name="slope_base">\n      <pose>0 0 0 0 0 0</pose>\n      <collision name="slope_collision">\n        <geometry>\n          <mesh><uri>model://slope.dae</uri></mesh>\n        </geometry>\n      </collision>\n      <visual name="slope_visual">\n        <geometry>\n          <mesh><uri>model://slope.dae</uri></mesh>\n        </geometry>\n      </visual>\n      <surface>\n        <friction>\n          <ode>\n            <mu>0.1</mu>    \x3c!-- Low friction --\x3e\n            <mu2>0.1</mu2>\n          </ode>\n        </friction>\n      </surface>\n    </link>\n\n    \x3c!-- Test object --\x3e\n    <link name="test_object">\n      <pose>0 0 2 0 0 0</pose>\n      <inertial>\n        <mass>1.0</mass>\n        <inertia>\n          <ixx>0.01</ixx><ixy>0</ixy><ixz>0</ixz>\n          <iyy>0.01</iyy><iyz>0</iyz>\n          <izz>0.01</izz>\n        </inertia>\n      </inertial>\n      <collision name="object_collision">\n        <geometry>\n          <sphere><radius>0.1</radius></sphere>\n        </geometry>\n      </collision>\n      <visual name="object_visual">\n        <geometry>\n          <sphere><radius>0.1</radius></sphere>\n        </geometry>\n      </visual>\n    </link>\n  </model>\n</sdf>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"validating-physics-simulation-accuracy",children:"Validating Physics Simulation Accuracy"}),"\n",(0,o.jsx)(n.h3,{id:"method-1-comparing-with-real-world-physics",children:"Method 1: Comparing with Real-World Physics"}),"\n",(0,o.jsx)(n.p,{children:"To validate your physics simulation, compare the behavior of objects in simulation with real-world expectations:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Free Fall Test"}),": Drop an object and measure its acceleration"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pendulum Test"}),": Simulate a pendulum and compare period with theoretical calculation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Collision Test"}),": Test collisions between objects and verify conservation of momentum"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"method-2-using-built-in-gazebo-tools",children:"Method 2: Using Built-in Gazebo Tools"}),"\n",(0,o.jsx)(n.p,{children:"Gazebo provides several tools to help validate physics:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Check physics statistics\ngz stats\n\n# Monitor physics topics\nros2 topic echo /gazebo/model_state\n\n# Get detailed physics information\ngz service -s /gazebo/worlds --req-type gz.msgs.StringMsg --rep-type gz.msgs.StringMsg --timeout 1000\n"})}),"\n",(0,o.jsx)(n.h3,{id:"method-3-creating-validation-scripts",children:"Method 3: Creating Validation Scripts"}),"\n",(0,o.jsx)(n.p,{children:"Create a Python script to validate physics behavior:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nPhysics validation script for humanoid robot simulation\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64\nfrom geometry_msgs.msg import Pose\nfrom gazebo_msgs.msg import ModelStates\nimport numpy as np\nimport math\n\nclass PhysicsValidator(Node):\n    def __init__(self):\n        super().__init__(\'physics_validator\')\n\n        # Subscribe to Gazebo model states\n        self.model_sub = self.create_subscription(\n            ModelStates,\n            \'/gazebo/model_states\',\n            self.model_callback,\n            10\n        )\n\n        # Timer for periodic validation\n        self.timer = self.create_timer(0.1, self.validate_physics)\n\n        self.initial_pose = None\n        self.start_time = self.get_clock().now()\n        self.gravity_measured = False\n\n        self.get_logger().info(\'Physics Validator initialized\')\n\n    def model_callback(self, msg):\n        """Callback to get model positions"""\n        # Find your test object in the model states\n        for i, name in enumerate(msg.name):\n            if name == \'test_sphere\':\n                self.current_pose = msg.pose[i]\n                break\n\n    def validate_physics(self):\n        """Validate physics simulation"""\n        if self.current_pose is not None:\n            # Calculate position and velocity\n            pos_z = self.current_pose.position.z\n\n            # Calculate expected position under gravity: z = z0 - 0.5*g*t^2\n            current_time = self.get_clock().now()\n            elapsed_time = (current_time - self.start_time).nanoseconds / 1e9\n\n            # Assuming initial drop from height z0 = 2.0m\n            z0 = 2.0\n            expected_pos = z0 - 0.5 * 9.8 * elapsed_time**2\n\n            if expected_pos < 0:  # Hit the ground\n                expected_pos = 0.0\n\n            error = abs(pos_z - expected_pos)\n\n            if error < 0.1:  # Within tolerance\n                self.get_logger().info(f\'Physics validation passed: error = {error:.3f}\')\n            else:\n                self.get_logger().warn(f\'Physics validation failed: error = {error:.3f}\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    validator = PhysicsValidator()\n\n    try:\n        rclpy.spin(validator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        validator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"different-physics-engines-comparison",children:"Different Physics Engines Comparison"}),"\n",(0,o.jsx)(n.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pros"}),": Stable, widely used, good for general-purpose simulation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cons"}),": May struggle with complex contacts"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Best for"}),": Standard humanoid robot simulation, general robotics research"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"bullet",children:"Bullet"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pros"}),": Advanced collision detection, good for complex geometries"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cons"}),": Can be less stable with certain configurations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Best for"}),": Complex contact scenarios, articulated robots with many joints"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"dart",children:"DART"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pros"}),": Highly accurate, robust constraint solving"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cons"}),": Higher computational overhead"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Best for"}),": Precise physics simulation, biomechanical modeling"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"practical-exercise-configuring-physics-for-your-humanoid-robot",children:"Practical Exercise: Configuring Physics for Your Humanoid Robot"}),"\n",(0,o.jsx)(n.p,{children:"Let's apply what we've learned by configuring physics for a simple humanoid robot model:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Create a physics configuration file"})," for your robot:"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.7">\n  <world name="humanoid_physics_world">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode" enabled="true" default="true">\n      <gravity>0 0 -9.8</gravity>\n\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>200</iters>    \x3c!-- Higher iterations for stability --\x3e\n          <sor>1.0</sor>\n        </solver>\n\n        <constraints>\n          <cfm>1e-5</cfm>       \x3c!-- Lower CFM for tighter constraints --\x3e\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>10.0</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Include your humanoid robot --\x3e\n    <include>\n      <uri>model://humanoid_robot</uri>\n    </include>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Configure individual robot links"})," with appropriate friction and contact properties:"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example for foot link with high friction --\x3e\n<link name="left_foot">\n  <collision name="left_foot_collision">\n    <geometry>\n      <box>\n        <size>0.15 0.08 0.02</size>\n      </box>\n    </geometry>\n    <surface>\n      <friction>\n        <ode>\n          <mu>0.8</mu>         \x3c!-- High friction for stable stance --\x3e\n          <mu2>0.8</mu2>\n        </ode>\n      </friction>\n      <contact>\n        <ode>\n          <kp>1e+6</kp>        \x3c!-- Stiff contact for solid footing --\x3e\n          <kd>1e+3</kd>\n          <max_vel>100.0</max_vel>\n          <min_depth>0.001</min_depth>\n        </ode>\n      </contact>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"In this lesson, we explored the fundamentals of physics simulation for humanoid robotics in Gazebo. We covered:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gravity configuration"}),": Setting appropriate gravitational forces for realistic movement"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Friction parameters"}),": Configuring static and dynamic friction for natural surface interactions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Collision detection"}),": Fine-tuning collision parameters for accurate physical interactions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Material properties"}),": Defining surface characteristics that affect robot-object interactions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Physics engines"}),": Understanding the differences between ODE, Bullet, and DART"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Validation techniques"}),": Methods to verify physics simulation accuracy"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The physics configuration we've established forms the foundation for realistic robot behavior in simulation. Properly configured physics parameters are essential for training humanoid robots that will eventually operate in the real world."}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(n.p,{children:"With physics fundamentals established, we're ready to move on to Lesson 2.2, where we'll explore LiDAR sensor simulation. The physics parameters we've configured here will provide the realistic environment needed for accurate sensor simulation."}),"\n",(0,o.jsx)(n.p,{children:"Before proceeding to the next lesson, ensure your physics configuration is working correctly by:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Testing different parameter values and observing their effects"}),"\n",(0,o.jsx)(n.li,{children:"Validating simulation behavior against real-world expectations"}),"\n",(0,o.jsx)(n.li,{children:"Verifying that your humanoid robot model interacts appropriately with the environment"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const o={},t=s.createContext(o);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);