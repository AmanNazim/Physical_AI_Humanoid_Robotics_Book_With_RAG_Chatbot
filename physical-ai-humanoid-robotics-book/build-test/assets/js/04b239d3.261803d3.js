"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[3352],{6170:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"module-1/ros2-architecture-and-communication/index","title":"Chapter 1 \u2013 ROS 2 and the Physical AI Nervous System","description":"Introduction","source":"@site/docs/module-1/1-ros2-architecture-and-communication/index.md","sourceDirName":"module-1/1-ros2-architecture-and-communication","slug":"/module-1/ros2-architecture-and-communication/","permalink":"/docs/module-1/ros2-architecture-and-communication/","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/physical-ai-humanoid-robotics-book/edit/main/docs/module-1/1-ros2-architecture-and-communication/index.md","tags":[],"version":"current","frontMatter":{"title":"Chapter 1 \u2013 ROS 2 and the Physical AI Nervous System"},"sidebar":"tutorialSidebar","previous":{"title":"Module 1: The Robotic Nervous System \u2013 ROS2 Foundations for Physical AI","permalink":"/docs/module-1/"},"next":{"title":"Lesson 1.1 - Introduction to ROS2 Architecture","permalink":"/docs/module-1/ros2-architecture-and-communication/lesson-1.1-introduction-to-ros2-architecture"}}');var s=t(4848),i=t(8453);const r={title:"Chapter 1 \u2013 ROS 2 and the Physical AI Nervous System"},a="Chapter 1 \u2013 ROS 2 and the Physical AI Nervous System",c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Lessons",id:"lessons",level:2},{value:"Lesson 1.1 \u2013 Introduction to ROS2 Architecture",id:"lesson-11--introduction-to-ros2-architecture",level:3},{value:"Lesson 1.2 \u2013 Environment Setup and Workspace Creation",id:"lesson-12--environment-setup-and-workspace-creation",level:3},{value:"Lesson 1.3 \u2013 Basic Publisher/Subscriber Implementation",id:"lesson-13--basic-publishersubscriber-implementation",level:3},{value:"Lesson 1.4 \u2013 ROS2 Command Line Tools",id:"lesson-14--ros2-command-line-tools",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-1--ros-2-and-the-physical-ai-nervous-system",children:"Chapter 1 \u2013 ROS 2 and the Physical AI Nervous System"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:'Welcome to the foundational chapter of Physical AI and humanoid robotics! This chapter introduces you to ROS2 (Robot Operating System 2), the communication framework that serves as the "nervous system" for robotic systems. Think of ROS2 as the infrastructure that allows different parts of a robot to communicate with each other - just like how your nervous system allows different parts of your body to coordinate.'}),"\n",(0,s.jsx)(n.p,{children:"In this chapter, we'll take a step-by-step approach to understanding how robots communicate internally. You'll learn how to set up the ROS2 environment, create communication pathways between different robot components, and implement the most fundamental communication pattern: publisher-subscriber. No prior robotics knowledge is required - we'll build concepts from the ground up with intuitive examples."}),"\n",(0,s.jsx)(n.p,{children:"This chapter is designed specifically for beginner to intermediate students and focuses on practical, hands-on learning. You'll start with simple concepts and gradually build toward more sophisticated implementations, creating your first ROS2 communication graph."}),"\n",(0,s.jsx)(n.p,{children:'ROS2 is not just a framework but a complete communication infrastructure that allows different parts of a robot to coordinate with each other. It enables distributed robotic systems through its DDS (Data Distribution Service) architecture, which provides a standardized way for different software components to exchange data. This architecture directly supports the book-level goal of building systems that connect "sensing the environment, processing information, making decisions, and executing precise movements in highly dynamic physical systems."'}),"\n",(0,s.jsx)(n.p,{children:'The concept of ROS2 as a "nervous system" is particularly apt because, like the biological nervous system, it allows for distributed processing while maintaining coordination. Different "nodes" (software components) can run on different computers, yet communicate seamlessly as if they were part of a single system. This architecture is fundamental to the implementation of the core ROS2 entities specified in the module specification, including nodes, topics, services, and parameters.'}),"\n",(0,s.jsx)(n.h2,{id:"lessons",children:"Lessons"}),"\n",(0,s.jsx)(n.h3,{id:"lesson-11--introduction-to-ros2-architecture",children:"Lesson 1.1 \u2013 Introduction to ROS2 Architecture"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Objective"}),": Understand what ROS2 is and its role as a communication middleware in robotic systems, compare ROS2 with ROS1 and understand the evolution, describe the DDS (Data Distribution Service) communication model"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scope"}),': This lesson introduces the fundamental concepts of ROS2 architecture. ROS2 is not just a framework but a complete communication infrastructure that allows different parts of a robot to coordinate with each other. We\'ll use intuitive analogies like the human nervous system to explain how ROS2 enables distributed robotic systems. The lesson covers the evolution from ROS1 to ROS2, focusing on improvements in security, real-time performance, and multi-robot systems. This directly supports the module specification requirement for "ROS2 middleware implementation for robot communication" and "Node-based architecture for distributed robot control."']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Outcome"}),": By the end of this lesson, you will understand what ROS2 is and its role as a communication middleware in robotic systems, and you'll be able to compare ROS2 with ROS1 and understand the evolution."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tools"}),": ROS2, DDS (Data Distribution Service)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"lesson-12--environment-setup-and-workspace-creation",children:"Lesson 1.2 \u2013 Environment Setup and Workspace Creation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Objective"}),": Install ROS2 Humble Hawksbill on Ubuntu 22.04 environment, create and configure a ROS2 workspace with proper directory structure, set up the development environment with colcon build system, verify ROS2 installation with basic commands"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scope"}),': This hands-on lesson guides you through setting up your ROS2 development environment. You\'ll install ROS2 Humble Hawksbill, create your first workspace, and configure the build system. The lesson emphasizes best practices for workspace organization and includes troubleshooting tips for common installation issues. You\'ll create your first package.xml and setup.py files, establishing a proper development workflow. This implements the module specification requirement for "environment setup for future development" and supports the "Python-based ROS2 control interfaces using rclpy" objective.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Outcome"}),": By the end of this lesson, you will have successfully installed ROS2 Humble Hawksbill on Ubuntu 22.04 environment, created and configured a ROS2 workspace with proper directory structure, set up the development environment with colcon build system, and verified ROS2 installation with basic commands."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tools"}),": ROS2 Humble Hawksbill, colcon build system, Ubuntu 22.04"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"lesson-13--basic-publishersubscriber-implementation",children:"Lesson 1.3 \u2013 Basic Publisher/Subscriber Implementation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Objective"}),": Write and execute a basic publisher node in Python, write and execute a basic subscriber node in Python, launch and test a ROS2 communication graph, understand the message flow between publisher and subscriber nodes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scope"}),': This practical lesson teaches you to implement the most fundamental ROS2 communication pattern: publisher-subscriber. You\'ll write your first ROS2 nodes in Python, creating a publisher that sends messages and a subscriber that receives them. The lesson emphasizes understanding message flow and the asynchronous nature of topic-based communication. This directly implements the module specification requirement for "Topic-based pub/sub communication patterns" and "Create basic ROS2 nodes, topics, services, and parameters for inter-process communication."']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Outcome"}),": By the end of this lesson, you will have written and executed a basic publisher node in Python, written and executed a basic subscriber node in Python, launched and tested a ROS2 communication graph, and understood the message flow between publisher and subscriber nodes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tools"}),": Python 3.8+, rclpy, ROS2"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"lesson-14--ros2-command-line-tools",children:"Lesson 1.4 \u2013 ROS2 Command Line Tools"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Objective"}),": Use ROS2 command-line tools to examine communication patterns, understand node status and communication topology, work with services and examine service communication, understand ROS_DOMAIN_ID and network isolation concepts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scope"}),": This lesson focuses on using ROS2's powerful command-line tools to examine and debug communication patterns. You'll learn to use ",(0,s.jsx)(n.code,{children:"ros2 topic"}),", ",(0,s.jsx)(n.code,{children:"ros2 node"}),", and ",(0,s.jsx)(n.code,{children:"ros2 service"}),' commands to inspect running systems. The lesson covers network isolation concepts and how ROS_DOMAIN_ID enables multiple ROS2 systems to operate on the same network without interference. This supports the module specification requirement for "Service-based request/response communication" and "Simulation-ready abstractions for Gazebo compatibility."']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Outcome"}),": By the end of this lesson, you will have used ROS2 command-line tools to examine communication patterns, understood node status and communication topology, worked with services and examined service communication, and understood ROS_DOMAIN_ID and network isolation concepts."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tools"}),": ROS2 command-line tools (",(0,s.jsx)(n.code,{children:"ros2 topic"}),", ",(0,s.jsx)(n.code,{children:"ros2 node"}),", ",(0,s.jsx)(n.code,{children:"ros2 service"}),")"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);