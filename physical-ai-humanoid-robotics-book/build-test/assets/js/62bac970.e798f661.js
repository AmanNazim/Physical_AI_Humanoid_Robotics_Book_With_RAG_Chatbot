"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[7125],{4828:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1/nodes-topics-services-robot-communication/nodes-multiple-communication-patterns","title":"Nodes with Multiple Communication Patterns","description":"Lesson Overview","source":"@site/docs/module-1/2-nodes-topics-services-robot-communication/nodes-multiple-communication-patterns.md","sourceDirName":"module-1/2-nodes-topics-services-robot-communication","slug":"/module-1/nodes-topics-services-robot-communication/nodes-multiple-communication-patterns","permalink":"/docs/module-1/nodes-topics-services-robot-communication/nodes-multiple-communication-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/physical-ai-humanoid-robotics-book/edit/main/docs/module-1/2-nodes-topics-services-robot-communication/nodes-multiple-communication-patterns.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Advanced ROS2 Communication Patterns","permalink":"/docs/module-1/nodes-topics-services-robot-communication/introduction"},"next":{"title":"Service-based Communication","permalink":"/docs/module-1/nodes-topics-services-robot-communication/service-based-communication"}}');var t=i(4848),o=i(8453);const a={sidebar_position:2},r="Nodes with Multiple Communication Patterns",l={},c=[{value:"Lesson Overview",id:"lesson-overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Required Tools and Technologies",id:"required-tools-and-technologies",level:2},{value:"Understanding Multi-Communication Nodes",id:"understanding-multi-communication-nodes",level:2},{value:"Creating a Node with Both Publishers and Subscribers",id:"creating-a-node-with-both-publishers-and-subscribers",level:2},{value:"Proper Node Lifecycle Management",id:"proper-node-lifecycle-management",level:2},{value:"Callback Execution Guarantees",id:"callback-execution-guarantees",level:2},{value:"Managing Different Message Types",id:"managing-different-message-types",level:2},{value:"Testing the Multi-Communication Node",id:"testing-the-multi-communication-node",level:2},{value:"Best Practices for Multi-Communication Nodes",id:"best-practices-for-multi-communication-nodes",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"nodes-with-multiple-communication-patterns",children:"Nodes with Multiple Communication Patterns"})}),"\n",(0,t.jsx)(n.h2,{id:"lesson-overview",children:"Lesson Overview"}),"\n",(0,t.jsx)(n.p,{children:"In this lesson, you will learn to create nodes that implement multiple communication patterns simultaneously, specifically nodes that both publish and subscribe to different topics within the same node process. This approach creates more sophisticated communication architectures that are essential for complex robotic systems. You will understand how to manage different message types and timing requirements within a single node while maintaining proper lifecycle management and callback execution guarantees."}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"After completing this lesson, you will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Design nodes that can both publish and subscribe to different topics within the same node"}),"\n",(0,t.jsx)(n.li,{children:"Implement proper node lifecycle management with multiple communication flows"}),"\n",(0,t.jsx)(n.li,{children:"Understand callback execution guarantees in multi-communication nodes"}),"\n",(0,t.jsx)(n.li,{children:"Manage different message types and timing requirements within a single node process"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"required-tools-and-technologies",children:"Required Tools and Technologies"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ROS2 Humble Hawksbill"}),"\n",(0,t.jsx)(n.li,{children:"rclpy (Python client library)"}),"\n",(0,t.jsx)(n.li,{children:"colcon build system"}),"\n",(0,t.jsx)(n.li,{children:"Standard ROS2 message types (sensor_msgs, std_msgs)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"understanding-multi-communication-nodes",children:"Understanding Multi-Communication Nodes"}),"\n",(0,t.jsx)(n.p,{children:"In basic ROS2 implementations, nodes typically either publish data or subscribe to data. However, complex robotic systems often require nodes that participate in multiple communication flows simultaneously. For example, a sensor processing node might subscribe to raw sensor data while publishing processed information to other nodes. This pattern enables more sophisticated robot architectures where nodes can serve multiple roles in the communication network."}),"\n",(0,t.jsx)(n.p,{children:"Multi-communication nodes offer several advantages:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reduced system complexity by consolidating related functionality"}),"\n",(0,t.jsx)(n.li,{children:"Lower latency between related operations within the same process"}),"\n",(0,t.jsx)(n.li,{children:"Simplified parameter and state management across communication patterns"}),"\n",(0,t.jsx)(n.li,{children:"More efficient resource utilization"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"However, they also introduce complexity in terms of callback management, timing coordination, and lifecycle handling."}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-node-with-both-publishers-and-subscribers",children:"Creating a Node with Both Publishers and Subscribers"}),"\n",(0,t.jsx)(n.p,{children:"Let's implement a node that demonstrates multiple communication patterns. This example will create a node that subscribes to sensor data and publishes processed information based on that data."}),"\n",(0,t.jsx)(n.p,{children:"First, create a new package for this lesson:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"mkdir -p ~/ros2_ws/src/advanced_communication_tutorials\ncd ~/ros2_ws/src/advanced_communication_tutorials\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create the package structure:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"mkdir -p advanced_communication_tutorials/launch\nmkdir -p advanced_communication_tutorials/config\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create the package.xml file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\n<package format="3">\n  <name>advanced_communication_tutorials</name>\n  <version>0.0.0</version>\n  <description>Advanced ROS2 Communication Tutorials</description>\n  <maintainer email="student@todo.todo">student</maintainer>\n  <license>Apache-2.0</license>\n\n  <depend>rclpy</depend>\n  <depend>std_msgs</depend>\n  <depend>sensor_msgs</depend>\n\n  <test_depend>ament_copyright</test_depend>\n  <test_depend>ament_flake8</test_depend>\n  <test_depend>ament_pep257</test_depend>\n  <test_depend>python3-pytest</test_depend>\n\n  <export>\n    <build_type>ament_python</build_type>\n  </export>\n</package>\n'})}),"\n",(0,t.jsx)(n.p,{children:"Create the setup.py file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\nfrom glob import glob\nimport os\n\npackage_name = 'advanced_communication_tutorials'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py')),\n        (os.path.join('share', package_name, 'config'), glob('config/*.yaml'))\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='student',\n    maintainer_email='student@todo.todo',\n    description='Advanced ROS2 Communication Tutorials',\n    license='Apache-2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'multi_communication_node = advanced_communication_tutorials.multi_communication_node:main',\n            'sensor_publisher = advanced_communication_tutorials.sensor_publisher:main',\n        ],\n    },\n)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now create the main Python module directory:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"mkdir -p advanced_communication_tutorials/advanced_communication_tutorials\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Create the multi-communication node implementation (",(0,t.jsx)(n.code,{children:"advanced_communication_tutorials/advanced_communication_tutorials/multi_communication_node.py"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\n"""\nNode that demonstrates multiple communication patterns simultaneously.\nThis node subscribes to sensor data and publishes processed information.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Float32\nfrom sensor_msgs.msg import JointState\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\n\n\nclass MultiCommunicationNode(Node):\n    """\n    A ROS2 node that demonstrates multiple communication patterns.\n    It subscribes to sensor data and publishes processed information.\n    """\n\n    def __init__(self):\n        super().__init__(\'multi_communication_node\')\n\n        # Create QoS profile for reliable communication\n        qos_profile = QoSProfile(\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE,\n            depth=10\n        )\n\n        # Publisher for processed sensor data\n        self.processed_data_publisher = self.create_publisher(\n            String,\n            \'processed_sensor_data\',\n            qos_profile\n        )\n\n        # Publisher for calculated values\n        self.calculated_value_publisher = self.create_publisher(\n            Float32,\n            \'calculated_value\',\n            qos_profile\n        )\n\n        # Subscriber for raw sensor data\n        self.sensor_subscriber = self.create_subscription(\n            JointState,\n            \'raw_sensor_data\',\n            self.sensor_callback,\n            qos_profile\n        )\n\n        # Timer for periodic publishing (independent of subscription)\n        self.timer = self.create_timer(1.0, self.timer_callback)\n        self.timer_counter = 0\n\n        self.get_logger().info(\'Multi-Communication Node initialized\')\n\n    def sensor_callback(self, msg):\n        """\n        Callback function for sensor data subscription.\n        Processes incoming sensor data and publishes results.\n        """\n        self.get_logger().info(f\'Received sensor data with {len(msg.name)} joints\')\n\n        # Process the sensor data\n        processed_info = self.process_sensor_data(msg)\n\n        # Publish processed data\n        processed_msg = String()\n        processed_msg.data = processed_info\n        self.processed_data_publisher.publish(processed_msg)\n\n        # Calculate and publish derived values\n        calculated_value = self.calculate_from_sensor_data(msg)\n        calculated_msg = Float32()\n        calculated_msg.data = calculated_value\n        self.calculated_value_publisher.publish(calculated_msg)\n\n        self.get_logger().info(f\'Published processed data: {processed_info}\')\n        self.get_logger().info(f\'Published calculated value: {calculated_value}\')\n\n    def process_sensor_data(self, joint_state_msg):\n        """\n        Process the incoming joint state data to extract meaningful information.\n        """\n        if len(joint_state_msg.position) > 0:\n            avg_position = sum(joint_state_msg.position) / len(joint_state_msg.position)\n            max_position = max(joint_state_msg.position)\n            min_position = min(joint_state_msg.position)\n\n            return f"Processed: avg={avg_position:.2f}, max={max_position:.2f}, min={min_position:.2f}"\n        else:\n            return "No position data available"\n\n    def calculate_from_sensor_data(self, joint_state_msg):\n        """\n        Calculate a derived value from sensor data.\n        """\n        if len(joint_state_msg.position) > 0:\n            # Calculate sum of absolute positions as an example\n            return sum(abs(pos) for pos in joint_state_msg.position)\n        else:\n            return 0.0\n\n    def timer_callback(self):\n        """\n        Timer callback that publishes data independently of subscriptions.\n        """\n        self.timer_counter += 1\n        timer_msg = String()\n        timer_msg.data = f\'Timer message #{self.timer_counter} - Node is active\'\n        self.processed_data_publisher.publish(timer_msg)\n        self.get_logger().info(f\'Timer published: {timer_msg.data}\')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = MultiCommunicationNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info(\'Node interrupted by user\')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Create a simple sensor publisher for testing (",(0,t.jsx)(n.code,{children:"advanced_communication_tutorials/advanced_communication_tutorials/sensor_publisher.py"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\n\"\"\"\nSimple sensor publisher for testing multi-communication nodes.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nimport math\nimport time\n\n\nclass SensorPublisher(Node):\n    \"\"\"\n    A simple node that publishes mock sensor data for testing.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('sensor_publisher')\n\n        self.publisher = self.create_publisher(JointState, 'raw_sensor_data', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n\n        # Initialize joint names and create a pattern\n        self.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5']\n        self.i = 0\n\n        self.get_logger().info('Sensor Publisher initialized')\n\n    def timer_callback(self):\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'base_link'\n\n        msg.name = self.joint_names\n        msg.position = []\n        msg.velocity = []\n        msg.effort = []\n\n        # Create a pattern of values that change over time\n        for j, joint_name in enumerate(self.joint_names):\n            position = math.sin(self.i * 0.1 + j) * 1.5\n            velocity = math.cos(self.i * 0.1 + j) * 0.5\n            effort = math.sin(self.i * 0.2 + j) * 0.1\n\n            msg.position.append(position)\n            msg.velocity.append(velocity)\n            msg.effort.append(effort)\n\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Publishing: positions={msg.position}')\n        self.i += 1\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    publisher = SensorPublisher()\n\n    try:\n        rclpy.spin(publisher)\n    except KeyboardInterrupt:\n        publisher.get_logger().info('Publisher interrupted by user')\n    finally:\n        publisher.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"proper-node-lifecycle-management",children:"Proper Node Lifecycle Management"}),"\n",(0,t.jsx)(n.p,{children:"When implementing nodes with multiple communication patterns, proper lifecycle management becomes crucial. The ROS2 lifecycle ensures that nodes initialize, execute, and shutdown cleanly. Here's how to properly manage a multi-communication node:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Initialization Phase"}),": All publishers, subscribers, timers, and services are created during the node initialization. Resources are allocated and initial configuration is loaded."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Execution Phase"}),": The node enters the spinning state where it processes callbacks from publishers, subscribers, timers, and services. Proper callback execution guarantees must be maintained."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Shutdown Phase"}),": All resources are properly cleaned up, connections are closed, and any necessary state is persisted."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The multi-communication node we created follows these principles by properly initializing all communication components in the constructor, handling callbacks appropriately during execution, and ensuring proper cleanup during shutdown."}),"\n",(0,t.jsx)(n.h2,{id:"callback-execution-guarantees",children:"Callback Execution Guarantees"}),"\n",(0,t.jsx)(n.p,{children:"In multi-communication nodes, you need to understand callback execution guarantees:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thread Safety"}),": ROS2 callbacks execute in a thread-safe manner within the same node, but you should still be careful when sharing data between callbacks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution Order"}),": There is no guaranteed order between different callback types (subscriber, timer, service). Your code should not rely on specific execution order."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timing Constraints"}),": Callbacks must complete within reasonable timeframes to avoid blocking other callbacks in the same node."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In our example, we ensure thread safety by not sharing mutable state between callbacks and keeping callback execution time minimal."}),"\n",(0,t.jsx)(n.h2,{id:"managing-different-message-types",children:"Managing Different Message Types"}),"\n",(0,t.jsx)(n.p,{children:"Multi-communication nodes often handle different message types simultaneously. In our example, we handle:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"sensor_msgs/JointState"})," for sensor data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"std_msgs/String"})," for processed information"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"std_msgs/Float32"})," for calculated values"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Each message type has its own purpose and timing requirements. The node processes each type appropriately based on the application's needs."}),"\n",(0,t.jsx)(n.h2,{id:"testing-the-multi-communication-node",children:"Testing the Multi-Communication Node"}),"\n",(0,t.jsx)(n.p,{children:"To test the multi-communication node, build the package:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select advanced_communication_tutorials\nsource install/setup.bash\n"})}),"\n",(0,t.jsx)(n.p,{children:"Run the sensor publisher in one terminal:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ros2 run advanced_communication_tutorials sensor_publisher\n"})}),"\n",(0,t.jsx)(n.p,{children:"Run the multi-communication node in another terminal:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ros2 run advanced_communication_tutorials multi_communication_node\n"})}),"\n",(0,t.jsx)(n.p,{children:"Monitor the topics to see the communication in action:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Monitor processed sensor data\nros2 topic echo /processed_sensor_data\n\n# Monitor calculated values\nros2 topic echo /calculated_value\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-for-multi-communication-nodes",children:"Best Practices for Multi-Communication Nodes"}),"\n",(0,t.jsx)(n.p,{children:"When designing nodes with multiple communication patterns, consider these best practices:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Clear Purpose"}),": Ensure the node has a clear, unified purpose that justifies combining multiple communication patterns."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Resource Management"}),": Properly manage resources and ensure all publishers, subscribers, and timers are created and destroyed correctly."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Implement proper error handling for each communication pattern to maintain system reliability."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Performance Monitoring"}),": Monitor the performance of multi-communication nodes as they can become bottlenecks if not designed properly."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Separation of Concerns"}),": Keep the different communication responsibilities distinct within the node to maintain code clarity."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"In this lesson, you learned how to create nodes that implement multiple communication patterns simultaneously. You implemented a node that both subscribes to sensor data and publishes processed information, while also maintaining a timer for independent publishing. You learned about proper lifecycle management, callback execution guarantees, and how to manage different message types within a single node. This foundation prepares you for more advanced communication patterns in the following lessons."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var s=i(6540);const t={},o=s.createContext(t);function a(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);